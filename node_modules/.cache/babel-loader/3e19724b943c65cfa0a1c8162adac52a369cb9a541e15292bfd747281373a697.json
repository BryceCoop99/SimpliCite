{"ast":null,"code":"var _jsxFileName = \"/usr/share/caddy/personal/formatter/src/App.js\";\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  let quotes = [];\n  let citations = [];\n  const firstDoubleQuote_CharVal = 8220;\n  const lastDoubleQuote_CharVal = 8221;\n  function finishesSentence(word) {\n    let letters = word.split('');\n    if (letters[word.length - 1] === '.') {\n      // If the last character is a decimal, return true!\n      console.log(\"TRUE!\");\n      return true;\n    } else {\n      return false;\n    }\n  }\n  function findMlaQuotes(startingIndex, inputSections, sectionWorksCited) {\n    console.log(startingIndex + \" \" + inputSections + \" \" + sectionWorksCited);\n    for (let secIndex = startingIndex; secIndex < sectionWorksCited; secIndex++) {\n      console.log(\"Section index: \" + secIndex);\n      const inputWords = inputSections[secIndex].split(\" \");\n      console.log(inputWords);\n\n      /* Time to find the quotes in a section*/\n      for (let i = 0; i < inputWords.length; i++) {\n        let word = inputWords[i];\n        // console.log(word);\n\n        if (word.charCodeAt(0) === firstDoubleQuote_CharVal) {\n          // First quoted word found, now find the last.\n          // console.log(\"Checking: \" +word);\n          let wordsInQuote = [];\n          wordsInQuote.push(word);\n          while (true) {\n            // Checking word with ending quotation marks!\n            i++;\n            word = inputWords[i];\n            const containsFinalQuote = word.charCodeAt(word.length - 1) === lastDoubleQuote_CharVal;\n            wordsInQuote.push(word);\n            if (containsFinalQuote) {\n              // console.log(\"Correct word! It was: \" +word);\n              break;\n            }\n          }\n          quotes.push(wordsInQuote.join(\" \"));\n          let citation = [];\n          let startCitationIndex = i;\n          let containsCitation = false;\n          // Get the citing of the quote after the quotation marks.\n          while (true) {\n            i++;\n            word = inputWords[i];\n            console.log(word);\n            if (word === undefined) {\n              // Break if this is the end of the word in the section.\n              break;\n            }\n            if (!word.includes(\"(\") && startCitationIndex === i) {\n              // If beginning of citation and doesn't include open parenthesis.\n              console.log(\"Citation does not come right after quote\");\n              // Do more...\n            } else if (word.includes(\"(\")) {\n              // If citation is right after quote.\n              word.replace(/[(]/g, ''); //Replaces start parenthesis with empty.\n              console.log(word);\n              if (word.includes(\")\")) {\n                // If word is also end of citation too.\n                containsCitation = true;\n                word.replace(/[)]/g, '');\n                console.log(word);\n                citation.push(word);\n                break;\n              }\n              if (word.includes(\",\")) {\n                // If the word has a comma, remove it\n                word.replace(/[,]/g, '');\n              }\n              citation.push(word);\n            } else if (word.includes(\")\")) {\n              // If this is the end of the citation.\n              containsCitation = true;\n              word.replace(/[)]/g, '');\n              console.log(word);\n              citation.push(word);\n              break;\n            } else {\n              console.log(word);\n              citation.push(word);\n            }\n          }\n          if (containsCitation) {\n            citations.push(citation.join(\" \"));\n            console.log(\"Citations: \" + citations);\n          } else {\n            let mostRecentQuoteIndex = quotes.length - 1;\n            console.log(\"Quote: \" + quotes[mostRecentQuoteIndex] + \" does not have a citation\");\n          }\n\n          // If citing doesn't come right after quote, check if it's later in the same section.\n          // while (true) {\n          //   i++;\n          //   word = inputWords[i];\n\n          //   // Check if the next word is the citing.\n          //   if (word.includes(\"(\")) {\n\n          //   } else { // If the word doesn't contain a parenthesis, find the next quote.\n\n          //   }\n\n          // }\n        }\n      }\n    }\n\n    console.log(\"Quotes: \" + quotes);\n  }\n  function checkMlaHandler(e) {\n    e.preventDefault();\n    const inputText = document.getElementById(\"inputText\").value;\n    console.log(inputText);\n    if (inputText === undefined) {\n      return;\n    }\n    const inputSections = inputText.split(\"\\n\");\n    console.log(\"Number of sections: \" + inputSections.length);\n\n    /* Find the starting paragraph to parse! */\n    let startParsingIndex = 0;\n    for (let i = 0; i < inputSections.length; i++) {\n      if (inputSections[i].length > 50) {\n        startParsingIndex = i;\n        break;\n      }\n    }\n    console.log(\"Starting section: \" + (startParsingIndex + 1));\n    /* If the starting section isn't 5, you are missing headers or added too many header/title lines */\n    if (startParsingIndex < 5) {\n      console.log(\"User is missing header information\");\n      return;\n    } else if (startParsingIndex > 5) {\n      console.log(\"User added too many header/title lines before introduction of paper\");\n      return;\n    }\n    let sectionWorksCited;\n    /* Check where the Works Cited page might exist! */\n    for (let sectionNum = startParsingIndex; sectionNum < inputSections.length; sectionNum++) {\n      if (inputSections[sectionNum].split(\" \").length === 2) {\n        sectionWorksCited = sectionNum;\n        // console.log(\"Possible Works Cited page on section \" +(sectionNum+1)+ \"?\");\n      }\n    }\n\n    findMlaQuotes(startParsingIndex, inputSections, sectionWorksCited);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"document\",\n      children: [/*#__PURE__*/_jsxDEV(\"textarea\", {\n        id: \"inputText\",\n        className: \"inputText\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 174,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: checkMlaHandler,\n        children: \"Check Text\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 175,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 173,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 172,\n    columnNumber: 5\n  }, this);\n}\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["App","quotes","citations","firstDoubleQuote_CharVal","lastDoubleQuote_CharVal","finishesSentence","word","letters","split","length","console","log","findMlaQuotes","startingIndex","inputSections","sectionWorksCited","secIndex","inputWords","i","charCodeAt","wordsInQuote","push","containsFinalQuote","join","citation","startCitationIndex","containsCitation","undefined","includes","replace","mostRecentQuoteIndex","checkMlaHandler","e","preventDefault","inputText","document","getElementById","value","startParsingIndex","sectionNum"],"sources":["/usr/share/caddy/personal/formatter/src/App.js"],"sourcesContent":["import './App.css';\n\nfunction App() {\n    \n  let quotes = [];\n  let citations = [];\n  const firstDoubleQuote_CharVal = 8220;\n  const lastDoubleQuote_CharVal = 8221;\n  \n  function finishesSentence(word) {\n    let letters = word.split('');\n    if (letters[(word.length-1)] === '.') { // If the last character is a decimal, return true!\n      console.log(\"TRUE!\");\n      return true;\n    } else {\n      return false;\n    }\n  }\n  \n  function findMlaQuotes(startingIndex, inputSections, sectionWorksCited) {\n    console.log(startingIndex+ \" \" +inputSections+ \" \" +sectionWorksCited);\n    \n    for (let secIndex = startingIndex; secIndex < sectionWorksCited; secIndex++) {\n      console.log(\"Section index: \" +secIndex);\n      const inputWords = inputSections[secIndex].split(\" \");\n      console.log(inputWords);\n    \n      /* Time to find the quotes in a section*/\n      for (let i = 0; i < inputWords.length; i++) {\n        let word = inputWords[i];\n        // console.log(word);\n        \n        if (word.charCodeAt(0) === firstDoubleQuote_CharVal) { // First quoted word found, now find the last.\n          // console.log(\"Checking: \" +word);\n          let wordsInQuote = [];\n          wordsInQuote.push(word);\n          \n          while (true) { // Checking word with ending quotation marks!\n            i++;\n            word = inputWords[i];\n            const containsFinalQuote = (word.charCodeAt(word.length -1) === lastDoubleQuote_CharVal);\n            wordsInQuote.push(word);\n            \n            if (containsFinalQuote) {\n              // console.log(\"Correct word! It was: \" +word);\n              break;\n            }\n          }\n          \n          quotes.push(wordsInQuote.join(\" \"));\n          \n          let citation = [];\n          let startCitationIndex = i;\n          let containsCitation = false;\n          // Get the citing of the quote after the quotation marks.\n          while (true) {\n            i++;\n            word = inputWords[i];\n            console.log(word);\n            \n            if (word === undefined) { // Break if this is the end of the word in the section.\n              break;\n            }\n            \n            if (!word.includes(\"(\") && (startCitationIndex === i)) { // If beginning of citation and doesn't include open parenthesis.\n              console.log(\"Citation does not come right after quote\");\n              // Do more...\n              \n            } else if (word.includes(\"(\")) { // If citation is right after quote.\n              word.replace(/[(]/g, ''); //Replaces start parenthesis with empty.\n              console.log(word);\n              \n              if (word.includes(\")\")) { // If word is also end of citation too.\n                containsCitation = true;\n                word.replace(/[)]/g, '');\n                console.log(word);\n                citation.push(word);\n                break;\n              }\n              if (word.includes(\",\")) { // If the word has a comma, remove it\n                word.replace(/[,]/g, '');\n              }\n              citation.push(word);\n              \n            } else if (word.includes(\")\")) { // If this is the end of the citation.\n              containsCitation = true;\n              word.replace(/[)]/g, '');\n              console.log(word);\n              citation.push(word);\n              break;\n            } else {\n              console.log(word);\n              citation.push(word);\n            }\n            \n          }\n          \n          if (containsCitation) {\n            citations.push(citation.join(\" \"));\n            console.log(\"Citations: \" +citations);\n          } else {\n            let mostRecentQuoteIndex = (quotes.length -1);\n            console.log(\"Quote: \" +quotes[mostRecentQuoteIndex]+ \" does not have a citation\");\n          }\n          \n          // If citing doesn't come right after quote, check if it's later in the same section.\n          // while (true) {\n          //   i++;\n          //   word = inputWords[i];\n            \n          //   // Check if the next word is the citing.\n          //   if (word.includes(\"(\")) {\n              \n              \n          //   } else { // If the word doesn't contain a parenthesis, find the next quote.\n              \n          //   }\n            \n          // }\n        \n        }\n      }\n    }\n    console.log(\"Quotes: \" +quotes);\n  }\n  \n  function checkMlaHandler(e) {\n    e.preventDefault();\n    \n    const inputText = document.getElementById(\"inputText\").value;\n    console.log(inputText);\n    \n    if (inputText === undefined) {\n      return;\n    }\n    \n    const inputSections = inputText.split(\"\\n\");\n    console.log(\"Number of sections: \" +inputSections.length);\n    \n    /* Find the starting paragraph to parse! */\n    let startParsingIndex = 0;\n    for (let i = 0; i < inputSections.length; i++) {\n      if (inputSections[i].length > 50) {\n        startParsingIndex = i;\n        break;\n      }\n    }\n    \n    console.log(\"Starting section: \" +(startParsingIndex+1));\n    /* If the starting section isn't 5, you are missing headers or added too many header/title lines */\n    if (startParsingIndex < 5) {\n      console.log(\"User is missing header information\");\n      return;\n    } else if (startParsingIndex > 5) {\n      console.log(\"User added too many header/title lines before introduction of paper\");\n      return;\n    }\n    \n    let sectionWorksCited;\n    /* Check where the Works Cited page might exist! */\n    for (let sectionNum = startParsingIndex; sectionNum < inputSections.length; sectionNum++) {\n      if (inputSections[sectionNum].split(\" \").length === 2) {\n        sectionWorksCited = sectionNum;\n        // console.log(\"Possible Works Cited page on section \" +(sectionNum+1)+ \"?\");\n      }\n    }\n    \n    findMlaQuotes(startParsingIndex, inputSections, sectionWorksCited);\n  }\n  \n  return (\n    <div className=\"App\">\n      <div className=\"document\">\n        <textarea id=\"inputText\" className=\"inputText\"/>\n        <button onClick={checkMlaHandler}>Check Text</button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}