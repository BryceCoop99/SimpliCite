{"ast":null,"code":"var _jsxFileName = \"/usr/share/caddy/personal/formatter/src/App.js\";\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  function checkTextHandler(e) {\n    e.preventDefault();\n    const firstDoubleQuote_CharVal = 8220;\n    const lastDoubleQuote_CharVal = 8221;\n    const inputText = document.getElementById(\"inputText\").value;\n    console.log(inputText);\n    if (inputText === undefined) {\n      return;\n    }\n    const inputSections = inputText.split(\"\\n\");\n    console.log(\"Number of sections: \" + inputSections.length);\n    let startParsingIndex = 0;\n    for (let i = 0; i < inputSections.length; i++) {\n      // Find the starting paragraph to parse!\n      if (inputSections[i].length > 50) {\n        startParsingIndex = i;\n        break;\n      }\n    }\n    console.log(\"Starting section: \" + (startParsingIndex + 1));\n    // If the starting section isn't 5, you are missing headers or added too many header/title lines\n    if (startParsingIndex < 5) {\n      console.log(\"User is missing header information\");\n      return;\n    } else if (startParsingIndex > 5) {\n      console.log(\"User added too many header/title lines before introduction of paper\");\n      return;\n    }\n    const inputWords = inputSections[startParsingIndex].split(\" \");\n    let quotes = [];\n    for (let sectionNum = startParsingIndex; sectionNum < inputSections.length; sectionNum++) {\n      if (inputSections[sectionNum].length < 10) {\n        console.log(\"Possible Works Cited page on section \" + (sectionNum + 1) + \"?\");\n      }\n    }\n    for (let i = 0; i < inputWords.length; i++) {\n      let word = inputWords[i];\n      // console.log(word);\n\n      if (word.charCodeAt(0) === firstDoubleQuote_CharVal) {\n        // First quoted word found, now find the last.\n        console.log(\"Checking: \" + word);\n        let wordsInQuote = [];\n        wordsInQuote.push(word);\n        while (true) {\n          // Checking word with ending quotation marks!\n          i++;\n          word = inputWords[i];\n          const containsFinalQuote = word.charCodeAt(word.length - 1) === lastDoubleQuote_CharVal;\n          wordsInQuote.push(word);\n          if (containsFinalQuote) {\n            console.log(\"Correct word! It was: \" + word);\n            break;\n          }\n        }\n        quotes.push(wordsInQuote.join(\" \"));\n\n        // Get the citing of the quote after the quotation marks.\n        // while (true) {\n        //   i++;\n        //   word = inputWords[i];\n\n        //   // Check if the next word is the citing.\n        //   if (word.includes(\"(\")) {\n        //   } else { // If the word doesn't contain a parenthesis, find the next quote.\n\n        //   }\n\n        // }\n      }\n    }\n\n    console.log(quotes);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"document\",\n      children: [/*#__PURE__*/_jsxDEV(\"textarea\", {\n        id: \"inputText\",\n        className: \"inputText\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 94,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: checkTextHandler,\n        children: \"Check Text\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 95,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 92,\n    columnNumber: 5\n  }, this);\n}\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["App","checkTextHandler","e","preventDefault","firstDoubleQuote_CharVal","lastDoubleQuote_CharVal","inputText","document","getElementById","value","console","log","undefined","inputSections","split","length","startParsingIndex","i","inputWords","quotes","sectionNum","word","charCodeAt","wordsInQuote","push","containsFinalQuote","join"],"sources":["/usr/share/caddy/personal/formatter/src/App.js"],"sourcesContent":["import './App.css';\n\nfunction App() {\n  \n  function checkTextHandler(e) {\n    e.preventDefault();\n    const firstDoubleQuote_CharVal = 8220;\n    const lastDoubleQuote_CharVal = 8221;\n    \n    const inputText = document.getElementById(\"inputText\").value;\n    console.log(inputText);\n    \n    if (inputText === undefined) {\n      return;\n    }\n    \n    const inputSections = inputText.split(\"\\n\");\n    console.log(\"Number of sections: \" +inputSections.length);\n    \n    let startParsingIndex = 0;\n    for (let i = 0; i < inputSections.length; i++) { // Find the starting paragraph to parse!\n      if (inputSections[i].length > 50) {\n        startParsingIndex = i;\n        break;\n      }\n    }\n    \n    console.log(\"Starting section: \" +(startParsingIndex+1));\n    // If the starting section isn't 5, you are missing headers or added too many header/title lines\n    if (startParsingIndex < 5) {\n      console.log(\"User is missing header information\");\n      return;\n    } else if (startParsingIndex > 5) {\n      console.log(\"User added too many header/title lines before introduction of paper\");\n      return;\n    }\n    \n    const inputWords = inputSections[startParsingIndex].split(\" \");\n    \n    let quotes = [];\n    \n    for (let sectionNum = startParsingIndex; sectionNum < inputSections.length; sectionNum++) {\n      if (inputSections[sectionNum].length < 10) {\n        console.log(\"Possible Works Cited page on section \" +(sectionNum+1)+ \"?\");\n      }\n    }\n    \n    \n    \n    for (let i = 0; i < inputWords.length; i++) {\n      let word = inputWords[i];\n      // console.log(word);\n      \n      if (word.charCodeAt(0) === firstDoubleQuote_CharVal) { // First quoted word found, now find the last.\n        console.log(\"Checking: \" +word);\n        let wordsInQuote = [];\n        wordsInQuote.push(word);\n        \n        while (true) { // Checking word with ending quotation marks!\n          i++;\n          word = inputWords[i];\n          const containsFinalQuote = (word.charCodeAt(word.length -1) === lastDoubleQuote_CharVal);\n          wordsInQuote.push(word);\n          \n          if (containsFinalQuote) {\n            console.log(\"Correct word! It was: \" +word);\n            break;\n          }\n        }\n        \n        quotes.push(wordsInQuote.join(\" \"));\n        \n        // Get the citing of the quote after the quotation marks.\n        // while (true) {\n        //   i++;\n        //   word = inputWords[i];\n          \n        //   // Check if the next word is the citing.\n        //   if (word.includes(\"(\")) {\n        //   } else { // If the word doesn't contain a parenthesis, find the next quote.\n            \n        //   }\n          \n        // }\n      \n      }\n    }\n    console.log(quotes);\n  }\n  \n  return (\n    <div className=\"App\">\n      <div className=\"document\">\n        <textarea id=\"inputText\" className=\"inputText\"/>\n        <button onClick={checkTextHandler}>Check Text</button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}