{"ast":null,"code":"var _jsxFileName = \"/usr/share/caddy/personal/formatter/src/App.js\",\n  _s = $RefreshSig$();\nimport './App.css';\nimport { Quote } from './models/Quote.js';\nimport { CitationError } from './models/CitationError.js';\nimport { DocumentError } from './models/DocumentError.js';\nimport { MLAWorksCitation } from './models/MLAWorksCitation.js';\nimport { useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  let documentErrorList;\n  let dataEntriesList;\n  let citationsErrorList;\n  let worksCitedList;\n  let startOfPaperIndex;\n  let sectionWorksCited;\n  const [selectedFormat, setSelectedFormat] = useState(\"MLA\");\n  const firstDoubleQuote_CharValues = [8220, 34];\n  const lastDoubleQuote_CharValues = [8221, 34];\n  // 33: !    46: .    59: ;    63: ?\n\n  // Need Valid MLA inline-citation\n\n  function selectedFormatHandler(e) {\n    e.preventDefault();\n    let value = document.getElementById(\"selectedFormat\").value;\n    if (value !== selectedFormat) {\n      if (selectedFormat === \"MLA\") {\n        setSelectedFormat(\"APA\");\n      } else {\n        setSelectedFormat(\"MLA\");\n      }\n    }\n  }\n  function inputTextOnChange(e) {\n    e.preventDefault();\n    const responseImportant = document.getElementById(\"responseImportant\");\n    if (responseImportant.innerHTML === \"Copy and paste your text here\") {\n      responseImportant.innerHTML = \"Click Check Paper!\";\n      responseImportant.style.backgroundColor = \"#ff006a\";\n    }\n  }\n  function inputTextChangeOnBlur(e) {\n    e.preventDefault();\n    let inputText = document.getElementById(\"inputText\").value;\n    if (inputText.length === 0) {\n      const responseImportant = document.getElementById(\"responseImportant\");\n      responseImportant.innerHTML = \"Copy and paste your text here\";\n      responseImportant.style.backgroundColor = \"transparent\";\n    }\n  }\n  function inputTextChangeOnFocus(e) {\n    e.preventDefault();\n    const responseImportant = document.getElementById(\"responseImportant\");\n    if (responseImportant.innerHTML !== \"See results below\") {\n      responseImportant.style.backgroundColor = \"#ff006a\";\n    }\n  }\n  function clearTextArea(e) {\n    e.preventDefault();\n    document.getElementById(\"inputText\").value = \"\";\n    const responseImportant = document.getElementById(\"responseImportant\");\n    responseImportant.innerHTML = \"Copy and paste your text here\";\n    responseImportant.style.backgroundColor = \"transparent\";\n  }\n  function stripQuotations(quote) {\n    if (firstDoubleQuote_CharValues.includes(quote.charCodeAt(0))) {\n      quote = quote.substring(1);\n    }\n    if (lastDoubleQuote_CharValues.includes(quote.charCodeAt(quote.length - 1))) {\n      quote = quote.substring(0, quote.length - 1);\n    }\n    quote.replace(\"\\\"\", \"\");\n    return quote;\n  }\n  function addToCitationErrorList(citation, secIndex, index, errorMessage) {\n    let citationObject;\n    for (let i = 0; i < citationsErrorList.length; i++) {\n      let citationToCheck = citationsErrorList[i].getCitation();\n      if (citation === citationToCheck) {\n        citationObject = getCitationObject(citation);\n        let citationErrors = citationObject.getCitationErrors();\n        if (citationErrors === undefined) {\n          citationErrors = [];\n        }\n        citationErrors.push(\"This citation already exists.\");\n        citationObject.setCitationErrors(citationErrors);\n        break;\n      }\n    }\n    if (citationObject === undefined) {\n      citationObject = new CitationError(citation);\n      let citationErrors = [errorMessage];\n      citationObject.setCitationErrors(citationErrors);\n      citationObject.setCitationIndex(index);\n      citationObject.setCitationSection(secIndex);\n    }\n    citationsErrorList.push(citationObject);\n  }\n  function addCitationError(quote, citation, secIndex, index, errorMessage) {\n    quote = stripQuotations(quote);\n    let quoteObject;\n\n    /* If this is a citation for a quote */\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      if (quote === quoteToCheck) {\n        quoteObject = getQuoteObject(quote);\n        let citationToCheck = quoteObject.getCitation();\n        let citationErrors = quoteObject.getCitationErrors();\n        if (citationErrors === undefined) {\n          citationErrors = [];\n        }\n        if (citation === citationToCheck) {\n          citationErrors.push(\"This citation already exists for given quote.\");\n          // What about errorMessage here?\n        } else {\n          citationErrors.push(errorMessage);\n        }\n        quoteObject.setCitationErrors(errorMessage);\n        dataEntriesList.push(quoteObject);\n        return;\n      }\n    }\n    if (quoteObject === undefined) {\n      console.log(\"Could not add citation error to quotes list.\");\n    }\n  }\n\n  /* For now, there should only be one quote per citation! This will flip some time soon*/\n  function addCitation(quote, citation, secIndex, index) {\n    quote = stripQuotations(quote);\n    let quoteObject = undefined;\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      if (quote === quoteToCheck) {\n        quoteObject = getQuoteObject(quote);\n        let citationStr = quoteObject.getCitation();\n        if (citationStr === undefined) {\n          quoteObject.setCitation(citation);\n          quoteObject.setCitationIndex(index);\n          quoteObject.setCitationSection(secIndex);\n        } else {\n          quoteObject.setCitationError(\"This Citation exists at least twice for the quote in this paper.\");\n          addCitationError(quote, citation, secIndex, index);\n        }\n        dataEntriesList.push(quoteObject);\n        break;\n      }\n    }\n    if (quoteObject === undefined) {\n      // If quote does not exists with given citation.\n      let citationHasErrors = false;\n      for (let i = 0; i < citationsErrorList.length; i++) {\n        // Checking to see if has errors\n        let citationToCheck = citationsErrorList[i].getCitation();\n        if (citation === citationToCheck) {\n          citationHasErrors = true;\n          let citationObject = getCitationObject(citation);\n          console.log(citationObject);\n          let citationErrors = citationObject.getCitationErrors();\n          if (citationErrors === undefined) {\n            citationErrors = [];\n          }\n          citationErrors.push(\"This citation is not associated with any quote/block quote.\");\n          citationObject.setCitationErrors(citationErrors);\n          citationsErrorList.push(citationObject);\n          break;\n        }\n      }\n      if (!citationHasErrors) {\n        let citationObject = new CitationError(citation);\n        citationsErrorList.push(citationObject);\n      }\n    }\n  }\n  function getCitationObject(citation) {\n    let citationObject;\n    for (let i = 0; i < citationsErrorList.length; i++) {\n      let citationToCheck = citationsErrorList[i].getCitation();\n      if (citation === citationToCheck) {\n        citationObject = citationsErrorList.splice(i, 1);\n        citationObject = citationObject[0];\n        break;\n      }\n    }\n    return citationObject;\n  }\n  function getQuoteObject(quote) {\n    quote = stripQuotations(quote);\n    let quoteObject;\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      if (quote === quoteToCheck) {\n        quoteObject = dataEntriesList.splice(i, 1); //Removes the quoteObj from list.\n        quoteObject = quoteObject[0];\n        break;\n      }\n    }\n    return quoteObject;\n  }\n  function addQuote(quote, secIndex, index) {\n    quote = stripQuotations(quote);\n    let quoteObject;\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      if (quote === quoteToCheck) {\n        quoteObject = getQuoteObject(quote);\n        let quoteErrors = quoteObject.getQuoteErrors();\n        if (quoteErrors === undefined) {\n          quoteErrors = [];\n        }\n        quoteErrors.push(\"This quote already exists in this document\");\n        quoteObject.setQuoteErrors(quoteErrors);\n        break;\n      }\n    }\n    if (quoteObject === undefined) {\n      quoteObject = new Quote(quote);\n      let quoteErrors = [];\n      quoteObject.setQuoteErrors(quoteErrors);\n      quoteObject.setQuoteIndex(index);\n      quoteObject.setQuoteSection(secIndex);\n    }\n    dataEntriesList.push(quoteObject);\n  }\n  function addQuoteError(quote, errorMessage) {\n    quote = stripQuotations(quote);\n    let quoteObject = getQuoteObject(quote);\n    if (quoteObject === undefined) {\n      console.log(\"SYSTEM ERROR: Cannot add error to a quote that does not exist\");\n      return undefined;\n    }\n    let quoteErrors = quoteObject.getQuoteErrors();\n    if (quoteErrors === undefined) {\n      quoteErrors = [];\n    }\n    quoteErrors.push(errorMessage);\n    quoteObject.setQuoteErrors(quoteErrors);\n    dataEntriesList.unshift(quoteObject);\n  }\n  function addDocumentError(errorMessage, secIndex, index) {\n    let documentErrorObject = new DocumentError(errorMessage, secIndex, index);\n    documentErrorList.push(documentErrorObject);\n  }\n  function removeMlaDecimal(word) {\n    const chars = word.split('');\n    if (chars[word.length - 1] === '.') {\n      // If the last character is a decimal, remove it!\n      const result = word.slice(0, -1);\n      return result;\n    } else {\n      return word;\n    }\n  }\n  function capitalizeFirstLetter(word) {\n    return word.charAt(0).toUpperCase() + word.slice(1);\n  }\n\n  /** This should check that an author's name appears in here! Author must come from Works Cited list*/\n  function validateCitationInText(wordsInSection, citation) {\n    // DO NOT disable the comment below...\n    // eslint-disable-next-line\n    let sentences = wordsInSection.join(\" \").match(/[^\\.!\\?]+[\\.!\\?]+/g);\n    let sentencesWithQuotationCitation = [];\n    // console.log(\"Citation to check: \" +citation);\n\n    for (let sentenceIndex = 0; sentenceIndex < wordsInSection.length; sentenceIndex++) {\n      let sentence = sentences[sentenceIndex];\n      let hasBeginningQuoteInSentence = false;\n      let hasEndingQuoteInSentence = false;\n      if (sentence === undefined) {\n        continue;\n      }\n      for (let i = 0; i < sentence.length; i++) {\n        let character = sentence[i];\n        if (!hasBeginningQuoteInSentence && firstDoubleQuote_CharValues.includes(character.charCodeAt(0))) {\n          hasBeginningQuoteInSentence = true;\n        } else if (!hasEndingQuoteInSentence && lastDoubleQuote_CharValues.includes(character.charCodeAt(0))) {\n          hasEndingQuoteInSentence = true;\n          // console.log(\"Sentence: \"+sentence);\n          break;\n        }\n      }\n      if (hasBeginningQuoteInSentence) {\n        sentencesWithQuotationCitation.push(sentence);\n        // console.log(\"Has beginning quote! \" +sentencesWithQuotationCitation.join(\" \"));\n        // console.log(sentencesWithQuotationCitation.join(\" \").includes(citation));\n\n        if (hasEndingQuoteInSentence) {\n          // IF IT HAS ENDING QUOTATION MARKS, THE CITATION MUST EXIST AFTER QUOTE!\n          // console.log(\"Quote found! \" +sentencesWithQuotationCitation.join(\" \"));\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  function findMlaBlockCitation(wordsInSection, secIndex) {\n    if (wordsInSection.join(\" \").includes(\")\") && wordsInSection.join(\" \").includes(\"(\")) {\n      // Checks if the section contains a parenthesis. Possible block citation!\n      console.log(wordsInSection);\n      let citation = [];\n      let quote = [];\n      let i = 0;\n      let startedCitationIndex = 0;\n      while (true) {\n        let word = wordsInSection[i];\n        citation = findMlaCitations(word, startedCitationIndex, i, citation);\n        if (citation[0].includes(\")\") && citation[0].includes(\"(\")) {\n          // If citation was found\n          addQuote(quote.join(\" \"), secIndex, 0);\n          addCitation(quote.join(\" \"), citation.join(\" \"), secIndex, i);\n          return true;\n        } else if (!citation[0].includes(\"(\")) {\n          quote.push(word);\n        } else if (citation[0].includes(\"(\")) {\n          citation.push(word);\n        }\n        i++;\n      }\n    }\n    return false;\n  }\n  function findMlaCitations(word, startedCitationIndex, i, citation) {\n    if (!word.includes(\"(\") && citation === undefined) {\n      // If beginning of citation and doesn't include open parenthesis.\n      console.log(\"Citation does not come right after quote! WHOOPS\");\n      return [];\n    } else if (word.includes(\"(\") && startedCitationIndex === i) {\n      // If citation is right after quote.\n\n      if (word.includes(\")\")) {\n        // If word is also end of citation too.\n        const finalWord = removeMlaDecimal(word);\n        citation.push(finalWord);\n        return [citation.join(\" \")];\n      }\n      citation.push(word);\n    } else if (word.includes(\")\")) {\n      // If this is the end of the citation.\n      const finalWord = removeMlaDecimal(word);\n      citation.push(finalWord);\n      return [citation.join(\" \")];\n    } else {\n      citation.push(word);\n    }\n    return [citation.join(\" \")];\n  }\n\n  /**\n   * Finds all of the quotes in MLA Format and adds them to the Quotes List! \n   */\n  function findMlaQuotes(startingIndex, inputSections, sectionWorksCited) {\n    for (let secIndex = startingIndex; secIndex < sectionWorksCited; secIndex++) {\n      let currentSection = inputSections[secIndex].replace('\\t', \"\");\n      const wordsInSection = currentSection.split(\" \");\n      if (wordsInSection.length < 2) {\n        // We don't want empty sections!\n        continue;\n      }\n      let containsQuoteInSection = false;\n      let containsCitationInSection = false;\n      let hasQuoteErrorInSection = false;\n\n      /* Time to find the quotes in a section*/\n      for (let i = 0; i < wordsInSection.length; i++) {\n        let word = wordsInSection[i];\n        let containsQuote = false;\n        let quote;\n        let quoteErrors = [];\n        let citationErrors = [];\n        if (firstDoubleQuote_CharValues.includes(word.charCodeAt(0))) {\n          // First quoted word found, now find the last.\n          let wordsInQuote = [];\n          wordsInQuote.push(word);\n          let wordsinSectionLength = wordsInSection.length - 1;\n          let quoteIndex = i;\n          while (true) {\n            // Checking word with ending quotation marks!\n            i++;\n            word = wordsInSection[i];\n            word = removeMlaDecimal(word);\n            const containsFinalQuote = lastDoubleQuote_CharValues.includes(word.charCodeAt(word.length - 1));\n            wordsInQuote.push(word);\n            if (containsFinalQuote) {\n              containsQuoteInSection = true;\n              containsQuote = true;\n              break;\n            } else if (word.includes(\"(\")) {\n              // If a citation comes before an ending parenthesis, tell the user.\n              quoteErrors.push(\"Missing ending parenthesis. Is it possible that you missed one before the citation?\");\n              wordsInQuote.pop();\n              hasQuoteErrorInSection = true;\n              containsQuote = true;\n              break;\n            } else if (i === wordsinSectionLength) {\n              // If this is the last word in the section and doesn't contain any quotes, tell the user.\n              quoteErrors.push(\"Missing ending quotation marks!\");\n              hasQuoteErrorInSection = true;\n              containsQuote = true;\n              break;\n            }\n          }\n          quote = wordsInQuote.join(\" \");\n          let startedCitationIndex = i + 1;\n          let containsCitation = false;\n          let citation = [];\n          let citationIndex = 0;\n          let citationIndexFound = false;\n          let citationRightAfterQuote = true;\n\n          // Get the citing of the quote after the quotation marks.\n          while (true) {\n            i++;\n            if (wordsInSection.length === i) {\n              break;\n            }\n            word = wordsInSection[i];\n            if (firstDoubleQuote_CharValues.includes(word.charCodeAt(0))) {\n              // Could mean that this quote could be associated with the next quote?\n              i--;\n              break;\n            }\n            citation = findMlaCitations(word, startedCitationIndex, i, citation);\n\n            /* If citation hasn't been found yet, give it the index now that it's found!*/\n            if (!citationIndexFound && citation[0].includes(\"(\")) {\n              citationIndexFound = true;\n              citationIndex = i;\n              continue;\n            }\n\n            /* If the citation index isn't found yet and it's not the last word in the section, continue to next iteration*/\n            if (containsQuote && !citationIndexFound && i !== wordsInSection.length - 1) {\n              citationRightAfterQuote = false;\n              citation.splice(0, citation.length);\n              continue;\n            }\n            if (citation[0].includes(\")\") && citation[0].includes(\"(\")) {\n              // If citation was found\n              containsCitationInSection = true;\n              containsCitation = true;\n              break;\n            }\n          }\n          if (containsCitation) {\n            citation = citation.join(\" \");\n          }\n\n          /* If there's a quote where the citation doesn't come right after. Suggestion! */\n          if (!citationRightAfterQuote && containsQuote) {\n            citationErrors.push(\"Suggestion: add citation directly after the quote.\");\n          }\n\n          /* If there's a citation and a quote! */\n          if (containsCitation && containsQuote) {\n            addQuote(quote, secIndex, quoteIndex);\n            addCitation(quote, citation, secIndex, citationIndex);\n\n            // Validate citation\n            let citationValid = validateCitationInText(wordsInSection, citation);\n            if (!citationValid) {}\n          } else if (containsCitation && !containsQuote) {\n            // If there's only a citation\n            addToCitationErrorList(citation, \"No quote exists for the given citation\");\n          } else if (!containsCitation && containsQuote) {\n            // If there's only a quote\n            // Could be a quote from different paragraph? Idk...\n            addQuote(quote, secIndex, quoteIndex);\n            // let quoteLength = quote.length;\n            // addCitationError(quote, )\n            addQuoteError(quote, \"This quote does not have an in-text citation\");\n          }\n          if (containsQuote && quoteErrors !== undefined) {\n            quoteErrors.forEach(error => {\n              addQuoteError(quote, error);\n            });\n          }\n          if (containsCitation && citationErrors !== undefined) {\n            citationErrors.forEach(error => {\n              addToCitationErrorList(citation, secIndex, citationIndex, error);\n            });\n          }\n\n          //Repeat for multiple quotes/citations in paragraph.\n        }\n      }\n\n      if (!containsQuoteInSection && !hasQuoteErrorInSection) {\n        // If the section does not contain a quote in section or quote errors. Could it be a block citation?\n        containsCitationInSection = findMlaBlockCitation(wordsInSection, secIndex);\n      }\n      if (containsQuoteInSection && !containsCitationInSection) {// This could possibly be a single cited paper!\n      }\n      if (!containsCitationInSection && !containsQuoteInSection) {\n        addDocumentError(\"No quote or citation exists for this paragraph!\", secIndex, 0);\n      }\n    }\n  }\n\n  /**\n  * Author, Title of source, Title of container, Other contributors\n  * Version, Number, Publisher, Publication date, Location.\n  */\n  function findMlaWorksCited(sectionWorksCited, inputSections, totalNumberSections) {\n    for (let secIndex = sectionWorksCited; secIndex < totalNumberSections; secIndex++) {\n      let mlaWorksCitedObj = new MLAWorksCitation(inputSections[secIndex], secIndex);\n      // DO NOT disable the comment below...\n      // eslint-disable-next-line\n      let sentences = inputSections[secIndex].match(/[^\\.!\\?]+[\\.!\\?]+/g);\n      // for (let sentIndex = 0; sentIndex < sentences.length)\n      let sentenceIndex = 0;\n      if (sentences === null) {\n        // This is null instead of undefined because of the funky .match() function above.\n        addDocumentError(\"Add your works citations at the end of the paper under the Works Cited section!\", secIndex, 0);\n        return;\n      }\n\n      /* Find Author and Author Acronym! */\n      let authorSentence = sentences[sentenceIndex].trim();\n      authorSentence = authorSentence.replace('.', \"\");\n\n      // console.log(authorSentence);\n      // console.log(secIndex);\n      // if (authorSentence)\n      let authorNames = authorSentence.split(\",\");\n      let authorErrors = [];\n      if (authorNames === undefined) {\n        addDocumentError(\"Add your works citations at the end of the paper under the Works Cited section!\", secIndex, 0);\n        return;\n      }\n      mlaWorksCitedObj.setAuthorIndex(sentenceIndex);\n\n      // console.log(authorNames);\n      if (authorNames.length === 1) {\n        mlaWorksCitedObj.setAuthor(authorNames[0]);\n        authorErrors.push(\"Author name must include first and last name in the following format\" + \" 'Last Name, First Name (Optional: Middle Initial/Name).'\");\n      } else if (authorNames.length > 2) {\n        mlaWorksCitedObj.setAuthor(authorSentence);\n        authorErrors.push(\"Make sure to use the following format for the Author's name:\" + \" 'Last Name, First Name (Optional: Middle Initial/Name).'\");\n      } else {\n        let lastNames = authorNames[0].trim().split(\" \");\n        let firstNames = authorNames[1].trim().split(\" \");\n        let fullname = [];\n        firstNames.forEach(word => {\n          fullname.push(capitalizeFirstLetter(word.toLowerCase()));\n        });\n        lastNames.forEach(word => {\n          fullname.push(capitalizeFirstLetter(word.toLowerCase()));\n        });\n        mlaWorksCitedObj.setAuthor(fullname.join(\" \"));\n        let authorAcronym = [];\n        firstNames.forEach(word => {\n          authorAcronym.push(word.charAt(0));\n        });\n        lastNames.forEach(word => {\n          authorAcronym.push(word.charAt(0));\n        });\n        mlaWorksCitedObj.setAuthorAcronym(authorAcronym.join(\"\"));\n        // console.log(authorAcronym);\n        // console.log(firstNames);\n        // console.log(lastNames);\n      }\n\n      if (authorErrors !== undefined) {\n        let errors = mlaWorksCitedObj.getAuthorErrors();\n        if (errors === undefined) {\n          errors = [];\n        }\n        authorErrors.forEach(error => {\n          errors.push(error);\n        });\n        mlaWorksCitedObj.setAuthorErrors(errors);\n      }\n      sentenceIndex += 1;\n      /*   */\n\n      worksCitedList.push(mlaWorksCitedObj);\n    }\n    if (worksCitedList[0] === undefined) {\n      return false;\n    }\n    return true;\n  }\n  function insertCommentIntoArray(array, index, commentType, comment, wordLength) {\n    if (array.length < 2) {\n      array.push(index);\n      array.push(commentType);\n      array.push(comment);\n      array.push(wordLength);\n      return array;\n    }\n    for (let i = 0; i < array.length; i += 4) {\n      let indexToCheck = array[i];\n      if (index <= indexToCheck) {\n        array.splice(i, 0, wordLength);\n        array.splice(i, 0, comment);\n        array.splice(i, 0, commentType);\n        array.splice(i, 0, index);\n        return array;\n      }\n    }\n    array.push(index);\n    array.push(commentType);\n    array.push(comment);\n    array.push(wordLength);\n    return array;\n  }\n\n  /* Creates an array that holds indexes with errors/suggestions/correct statements for printing! */\n  function createSectionsArray(totalNumberOfSections) {\n    let sectionsArray = [];\n    for (let sectionIndex = 0; sectionIndex < totalNumberOfSections; sectionIndex++) {\n      let commentsArray = []; // The index & comment to the error!\n\n      /* Documents List! */\n      documentErrorList.forEach(documentErrorObj => {\n        if (documentErrorObj.getSection() === sectionIndex) {\n          let error = documentErrorObj.getError();\n          commentsArray = insertCommentIntoArray(commentsArray, documentErrorObj.getIndex(), \"Document Error\", error, 0);\n        }\n      });\n\n      /* Quotes/Citations List! */\n      dataEntriesList.forEach(quoteObject => {\n        // Quotes \n        if (quoteObject.getQuoteSection() === sectionIndex) {\n          let quoteWordLength = quoteObject.getQuote().split(\" \").length;\n          let errors = quoteObject.getQuoteErrors();\n          if (errors === undefined) {\n            // There should always be quote errors... for some reason :D\n            return;\n          }\n          if (errors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, quoteObject.getQuoteIndex(), \"Valid Quotation\", \"Correct quote format!\", quoteWordLength);\n          } else {\n            for (let i = 0; i < errors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, quoteObject.getQuoteIndex(), \"Quotation Error\", errors[i], quoteWordLength);\n            }\n          }\n        }\n\n        // Citations\n        if (quoteObject.getCitationSection() !== undefined && quoteObject.getCitationSection() === sectionIndex) {\n          let citationWordLength = quoteObject.getCitation().split(\" \").length;\n          let errors = quoteObject.getCitationErrors();\n          if (errors === undefined || errors.length < 1) {\n            // If there aren't any errors\n            commentsArray = insertCommentIntoArray(commentsArray, quoteObject.getCitationIndex(), \"Valid Citation\", \"Correct Citation.\", citationWordLength);\n          } else {\n            for (let i = 0; i < errors.length; i++) {\n              // insert each error!\n              commentsArray = insertCommentIntoArray(commentsArray, quoteObject.getCitationIndex(), \"Citation Error\", errors[i], citationWordLength);\n            }\n          }\n        }\n      });\n\n      /* Citation Errors List! */\n      citationsErrorList.forEach(citationError => {\n        console.log(citationError.getCitationSection() === sectionIndex);\n        if (citationError.getCitationSection() === sectionIndex) {\n          let errors = citationError.getCitationErrors();\n          if (errors === undefined) {\n            console.log(\"SYSTEM ERROR: citation error must include error message.\");\n            return;\n          }\n          for (let i = 0; i < errors.length; i++) {\n            let wordLength = citationError.getCitation().split(\" \").length;\n            console.log(errors[i]);\n            commentsArray = insertCommentIntoArray(commentsArray, citationError.getCitationIndex(), \"Citation Error\", errors[i], wordLength);\n          }\n        }\n      });\n\n      /* Works Cited List! */\n      worksCitedList.forEach(worksCitedObject => {\n        if (worksCitedObject.getSectionIndex() === sectionIndex) {\n          let authorErrors = worksCitedObject.getAuthorErrors();\n          let titleSourceErrors = worksCitedObject.getTitleSourceErrors();\n          let titleContainerErrors = worksCitedObject.getTitleContainerErrors();\n          let contributorsErrors = worksCitedObject.getContributorsErrors();\n          let versionErrors = worksCitedObject.getVersionErrors();\n          let publisherErrors = worksCitedObject.getPublisherErrors();\n          let publicationDateErrors = worksCitedObject.getPublicationDateErrors();\n          let locationDateErrors = worksCitedObject.getLocationErrors();\n          if (authorErrors === undefined || authorErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getAuthorIndex(), \"Valid Author\", \"Correct Author format.\", 0);\n          } else {\n            for (let i = 0; i < authorErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getAuthorIndex(), \"Invalid Author\", authorErrors[i], 0);\n            }\n          }\n          if (titleSourceErrors === undefined || titleSourceErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getTitleSourceIndex(), \"Valid Title Source\", \"Correct Title Source format.\", 0);\n          } else {\n            for (let i = 0; i < titleSourceErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getTitleSourceIndex(), \"Invalid Title Source\", titleSourceErrors[i]);\n            }\n          }\n          if (titleContainerErrors === undefined || titleContainerErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getTitleContainerIndex(), \"Valid Title Container\", \"Correct Title Container format.\", 0);\n          } else {\n            for (let i = 0; i < titleContainerErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getTitleContainerIndex(), \"Invalid Title Container\", titleContainerErrors[i], 0);\n            }\n          }\n          if (contributorsErrors === undefined || contributorsErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getContributorsIndex(), \"Valid Contributors\", \"Correct Contributor format.\", 0);\n          } else {\n            for (let i = 0; i < contributorsErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getContributorsIndex(), \"Invalid Contributors\", contributorsErrors[i], 0);\n            }\n          }\n          if (versionErrors === undefined || versionErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getVersionIndex(), \"Valid Version\", \"Correct Version format.\", 0);\n          } else {\n            for (let i = 0; i < versionErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getVersionIndex(), \"Invalid Version\", versionErrors[i], 0);\n            }\n          }\n          if (publisherErrors === undefined || publisherErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getPublisherIndex(), \"Valid Publisher\", \"Correct Publisher format.\", 0);\n          } else {\n            for (let i = 0; i < publisherErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getPublisherIndex(), \"Invalid Publisher\", publisherErrors[i], 0);\n            }\n          }\n          if (publicationDateErrors === undefined || publicationDateErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getPublicationDateIndex(), \"Valid Publication Date\", \"Correct Publicatoin Date format.\", 0);\n          } else {\n            for (let i = 0; i < publicationDateErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getPublicationDateIndex(), \"Invalid Publication Date\", publicationDateErrors[i], 0);\n            }\n          }\n          if (locationDateErrors === undefined || locationDateErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getLocationIndex(), \"Valid Location\", \"Correct Location format.\", 0);\n          } else {\n            for (let i = 0; i < locationDateErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getLocationIndex(), \"Invalid Location\", locationDateErrors[i], 0);\n            }\n          }\n        }\n      });\n      sectionsArray.push(commentsArray);\n    }\n    return sectionsArray;\n  }\n  function checkMlaHandler(e) {\n    e.preventDefault();\n    documentErrorList = [];\n    citationsErrorList = [];\n    dataEntriesList = [];\n    worksCitedList = [];\n    const responseImportant = document.getElementById(\"responseImportant\");\n    responseImportant.innerHTML = \"\";\n    const inputText = document.getElementById(\"inputText\").value;\n    if (inputText.length > 0) {\n      responseImportant.style.backgroundColor = \"#FF006A\";\n      // responseImportant.style.color = \"#FFF\";\n    }\n\n    let inputSections = inputText.split(\"\\n\");\n    if (inputSections.length <= 1) {\n      if (inputSections[0].length > 1) {\n        responseImportant.innerHTML = \"Make sure you've copied your whole paper before checking! \" + \"Include the following headers: Full Name, Teacher, Class Name, Today's Date.\";\n        return;\n      }\n      responseImportant.innerHTML = \"Copy and paste your paper to start!\";\n      return;\n    }\n\n    /* Parse the headers! */\n    let hasExtraLinesInHeaders = false;\n    let hasMissingHeaders = false;\n    let startParsingIndex = 0;\n    let inputHeaders = [];\n    for (let i = 0; i < inputSections.length; i++) {\n      if (inputSections[i].length < 1) {\n        hasExtraLinesInHeaders = true;\n        inputSections.splice(i, 1);\n        i--;\n      } else if (inputSections[i].length > 15) {\n        hasMissingHeaders = true;\n        break;\n      } else {\n        inputHeaders.push(inputSections[i]);\n      }\n      if (inputHeaders !== undefined && inputHeaders.length === 4) {\n        break;\n      }\n    }\n\n    /* Input Headers handling!! */\n    if (inputHeaders === undefined) {\n      responseImportant.innerHTML = \"his paper is empty\";\n      return;\n    } else if (inputHeaders.length < 4) {\n      addDocumentError(\"Missing headers! Headers must include: your name, your teacher's name, class name, and current date.\", 0, 0);\n    }\n    if (hasExtraLinesInHeaders) {\n      addDocumentError(\"Consider removing the extra lines between headers of your document.\", 0, 0);\n    }\n    if (hasMissingHeaders) {\n      addDocumentError(\"Header/Title is missing! Headers must include: your name, your teacher's name, class name, and current date.\" + \"If your title is over 15 words long, shorten it and click the Check Citation button again.\", 0, 0);\n    }\n\n    /* Parse up until the Title! */\n    let inputTitle;\n    let hasExtraLinesBeforeTitle = false;\n    for (let i = inputHeaders.length; i < inputSections.length; i++) {\n      if (inputSections[i].length < 2) {\n        hasExtraLinesBeforeTitle = true;\n        inputSections.splice(i, 1);\n        i--;\n      } else {\n        inputTitle = inputSections[i];\n        startParsingIndex = i + 1;\n        break;\n      }\n    }\n\n    /* Title Handling */\n    if (inputTitle === undefined) {\n      responseImportant.innerHTML = \"Please add more to your paper before checking!\";\n      return;\n    }\n    if (inputSections[startParsingIndex].length < 2 || hasExtraLinesBeforeTitle) {\n      addDocumentError(\"Consider removing the extra lines before and after the Title of your document.\", startParsingIndex - 1, 0);\n    }\n\n    /* Parse the extra lines after the Title! We don't want to use them :) */\n    for (let i = startParsingIndex; i < inputSections.length; i++) {\n      if (inputSections[i].length < 2) {\n        inputSections.splice(i, 1);\n        i--;\n      }\n    }\n\n    /* Removing any extra lines in the document.*/\n    startOfPaperIndex = undefined;\n    for (let i = 0; i < inputSections.length; i++) {\n      if (inputSections[i].length < 2) {\n        inputSections.splice(i, 1);\n        i--;\n      } else if (startOfPaperIndex === undefined && inputSections[i].split(\" \").length > 20) {\n        startOfPaperIndex = i;\n        break;\n      }\n    }\n    if (startOfPaperIndex === undefined) {\n      responseImportant.innerHTML = \"Please add more to your paper before checking!\";\n      return;\n    }\n    sectionWorksCited = undefined;\n    /* Give the section works cited the last section so the loop can work. */\n    for (let i = startParsingIndex; i < inputSections.length; i++) {\n      let text = inputSections[i].trim().split(\" \");\n      if (text.length === 2) {\n        text = text.join(\" \").toLowerCase();\n        if (text === \"works cited\" || text === \"references\" || text === \"bibliography\") {\n          sectionWorksCited = i;\n        }\n      }\n    }\n    if (sectionWorksCited === undefined) {\n      sectionWorksCited = inputSections.length;\n      responseImportant.innerHTML = \"Please include a works cited page at the end of your document. If your works cited page exists,\" + \" make sure to have a single line named 'Works Cited' before the citations\";\n      return;\n    }\n\n    /* Check for MLA Works Cited page and parse the works cited citations!*/\n    let hasWorksCitedCitations = false;\n    if (sectionWorksCited < inputSections.length) {\n      hasWorksCitedCitations = findMlaWorksCited(sectionWorksCited + 1, inputSections, inputSections.length);\n    }\n    if (!hasWorksCitedCitations) {\n      responseImportant.innerHTML = \"Add your source citations under your 'Works Cited' section at the end of the document.\";\n      return;\n    }\n\n    // console.log(inputSections);\n    // console.log(startOfPaperIndex, sectionWorksCited);\n\n    /* Now find the in-text quotes/citations inside the paper sections!*/\n    findMlaQuotes(startOfPaperIndex, inputSections, sectionWorksCited);\n\n    /* Check that citations alone are valid */\n\n    // console.log(dataEntriesList);\n    // console.log(citationsErrorList);\n    // console.log(worksCitedList);\n    // console.log(documentErrorList);\n\n    const sectionArrayObject = createSectionsArray(inputSections.length);\n    console.log(sectionArrayObject);\n    generateResultPaper(sectionArrayObject, inputSections);\n    console.log(\"\\nEND\\n\\n\");\n    responseImportant.innerHTML = \"See results below\";\n    responseImportant.style.backgroundColor = \"#3CD604\";\n  }\n  function generateResultPaper(sectionArrayObject, inputSections) {\n    /* Creating container for parent node */\n    const parent = document.getElementById(\"bottom-parent\");\n    parent.innerHTML = ''; // Clear previous results!\n    const resultsContainer = document.createElement(\"div\");\n    resultsContainer.classList.add(\"container-other\");\n\n    /* Creating side comment column nodes */\n    const leftColumnNode = document.createElement(\"div\");\n    leftColumnNode.classList.add(\"container-other\");\n    leftColumnNode.classList.add(\"left-column\");\n    const rightColumnNode = document.createElement(\"div\");\n    rightColumnNode.classList.add(\"container-other\");\n    rightColumnNode.classList.add(\"right-column\");\n\n    /* Creating results container so text nodes can be appended inside of the container */\n    const resultTitle = document.createElement(\"h1\");\n    const resultTitleText = document.createTextNode(\"Results\");\n    resultTitle.appendChild(resultTitleText);\n    resultsContainer.appendChild(resultTitle);\n\n    // let userOnlyErrors = false; // Based off of input\n    let commentNumber = 1;\n    /* Start creating the paper! parent -> resultsContainer -> text */\n    for (let secIndex = 0; secIndex < inputSections.length; secIndex++) {\n      const wordsInSection = inputSections[secIndex].split(\" \");\n      const sectionNode = document.createElement(\"p\");\n      const sectionArrayComments = sectionArrayObject[secIndex];\n      const commentNumOfItems = sectionArrayComments.length;\n      if (secIndex >= startOfPaperIndex && secIndex < sectionWorksCited) {\n        // To tab paragraphs!\n        const tabNode = document.createTextNode(\"\\u00a0\\u00a0\\u00a0\\u00a0\");\n        sectionNode.appendChild(tabNode);\n      }\n      let commentWordLength = 0;\n      let commentSpanNode;\n      let hasCommentHighlight = false;\n      for (let i = 0; i < wordsInSection.length; i++) {\n        const word = wordsInSection[i];\n        // const spanNode = document.createElement(\"span\");\n        const wordNode = document.createTextNode(word);\n        for (let commentIndex = 0; commentIndex < commentNumOfItems; commentIndex += 4) {\n          if (i === sectionArrayComments[commentIndex]) {\n            // console.log(secIndex + \" \" + sectionArrayComments[commentIndex]);\n            const commentType = sectionArrayComments[commentIndex + 1];\n            const commentTypeLower = commentType.toLowerCase();\n\n            // if (userOnlyErrors || (!commentTypeLower.includes(\"error\") || !commentTypeLower.includes(\"invalid\"))) {\n            //   continue;\n            // }\n\n            /** Determines how to highlight the text in the paper*/\n            if (commentWordLength === 0 && !hasCommentHighlight) {\n              hasCommentHighlight = true;\n              commentWordLength = sectionArrayComments[commentIndex + 3];\n              commentSpanNode = document.createElement(\"span\");\n              if (commentTypeLower.includes(\"error\") || commentTypeLower.includes(\"invalid\")) {\n                commentSpanNode.classList.add(\"red-text\");\n              } else if (commentTypeLower.includes(\"valid\")) {\n                commentSpanNode.classList.add(\"green-text\");\n              } else if (commentTypeLower.includes(\"suggestion\")) {\n                commentSpanNode.classList.add(\"yellow-text\");\n              }\n            }\n            const commentNumberNode = document.createTextNode(commentNumber);\n            const numberElement = document.createElement(\"span\");\n            if (commentTypeLower.includes(\"error\") || commentTypeLower.includes(\"invalid\")) {\n              numberElement.classList.add(\"red-number\");\n            } else if (commentTypeLower.includes(\"valid\")) {\n              numberElement.classList.add(\"green-number\");\n            } else if (commentTypeLower.includes(\"suggestion\")) {\n              numberElement.classList.add(\"yellow-number\");\n            }\n            numberElement.appendChild(commentNumberNode);\n            sectionNode.appendChild(numberElement);\n            let spaceNode3 = document.createTextNode(\" \");\n            sectionNode.appendChild(spaceNode3);\n\n            /** USE #2\n            * Create this or the textnodes/nodes from above will be placed over the nodes below in the Paper! \n            */\n            const containerHeader = document.createElement(\"div\");\n            containerHeader.classList.add(\"side-container-header\");\n            const commentNumberNode2 = document.createTextNode(commentNumber);\n            const numberElement2 = document.createElement(\"span\");\n            if (commentTypeLower.includes(\"error\") || commentTypeLower.includes(\"invalid\")) {\n              numberElement2.classList.add(\"red-number\");\n            } else if (commentTypeLower.includes(\"valid\") && !commentTypeLower.includes(\"invalid\")) {\n              numberElement2.classList.add(\"green-number\");\n            } else if (commentTypeLower.includes(\"suggestion\")) {\n              numberElement2.classList.add(\"yellow-number\");\n            }\n            numberElement2.appendChild(commentNumberNode2);\n\n            /* Comment Type Node */\n            const commentTypeTextNode = document.createTextNode(commentType);\n            const commentTypeElement = document.createElement(\"h3\");\n            commentTypeElement.append(commentTypeTextNode);\n\n            /* Comment Message Node */\n            const commentMessageText = sectionArrayComments[commentIndex + 2];\n            const commentMessageTextNode = document.createTextNode(commentMessageText);\n            const commentMessageNode = document.createElement(\"p\");\n            commentMessageNode.appendChild(commentMessageTextNode);\n\n            /* Comment Container Node */\n            const commentContainerNode = document.createElement(\"div\");\n            commentContainerNode.classList.add(\"side-container\");\n\n            /** Append comment number and type Comment Header div.\n            * Then append Comment Header div to Comment Container div.\n            */\n            containerHeader.appendChild(numberElement2);\n            containerHeader.appendChild(commentTypeElement);\n            commentContainerNode.appendChild(containerHeader);\n            commentContainerNode.appendChild(commentMessageNode);\n\n            /* If comment number is even, append it to right side. Else, left side.*/\n            if (commentNumber % 2 === 0) {\n              rightColumnNode.appendChild(commentContainerNode);\n            } else {\n              leftColumnNode.appendChild(commentContainerNode);\n            }\n            commentNumber += 1;\n          }\n        }\n\n        /* If there is a comment associated with the word, make sure the word is added to a highlighted span */\n        if (commentWordLength > 0) {\n          commentWordLength -= 1;\n          commentSpanNode.appendChild(wordNode);\n          const spaceNode2 = document.createTextNode(\" \");\n          commentSpanNode.appendChild(spaceNode2);\n\n          /* If this is the last word in the highlight. */\n          if (commentWordLength === 0) {\n            hasCommentHighlight = false;\n            sectionNode.appendChild(commentSpanNode);\n          }\n        } else {\n          // Else, just add it to the section node\n          sectionNode.appendChild(wordNode);\n          const spaceNode = document.createTextNode(\" \");\n          sectionNode.appendChild(spaceNode);\n        }\n      }\n      resultsContainer.append(sectionNode);\n    }\n\n    // const results = document.createElement(\"div\");\n    // resultsContainer.appendChild(results);\n\n    /* Add the results container at the end! */\n    parent.appendChild(leftColumnNode);\n    parent.appendChild(resultsContainer);\n    parent.appendChild(rightColumnNode);\n  }\n  function checkApaHandler(e) {\n    e.preventDefault();\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: \"parent\",\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"header\",\n      className: \"header\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1240,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"container\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Essay Format Checker\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1242,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n        className: \"inputForm\",\n        autoComplete: \"off\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"input-field\",\n          children: [/*#__PURE__*/_jsxDEV(\"textarea\", {\n            onChange: inputTextOnChange,\n            onBlur: inputTextChangeOnBlur,\n            onFocus: inputTextChangeOnFocus,\n            id: \"inputText\",\n            type: \"text\",\n            required: true\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1245,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            id: \"responseImportant\",\n            children: \"Copy and paste your text here\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1246,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1247,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1244,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"bottom-row\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"importantButtons\",\n            children: [selectedFormat === \"MLA\" ? /*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: checkMlaHandler,\n              type: \"submit\",\n              value: \"Check Paper\",\n              className: \"btn btn-check\",\n              children: \"Check for MLA format\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1252,\n              columnNumber: 15\n            }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: checkApaHandler,\n              type: \"submit\",\n              value: \"Check Paper\",\n              className: \"btn btn-check\",\n              children: \"Check for APA format\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1254,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"select\", {\n              onChange: selectedFormatHandler,\n              id: \"selectedFormat\",\n              name: \"inputFormat\",\n              className: \"btn btn-select\",\n              children: [/*#__PURE__*/_jsxDEV(\"option\", {\n                value: \"MLA\",\n                children: \"MLA\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1257,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: \"APA\",\n                children: \"APA\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1258,\n                columnNumber: 17\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1256,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1250,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: clearTextArea,\n            type: \"submit\",\n            value: \"Clear\",\n            className: \"btn btn-clear\",\n            children: \"Clear\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1261,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1249,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1243,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1241,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"bottom-parent\",\n      className: \"bottom-parent\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1266,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1239,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"5eaqpuRFQIFzYlA7FC7sZXKuDDA=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["Quote","CitationError","DocumentError","MLAWorksCitation","useState","App","documentErrorList","dataEntriesList","citationsErrorList","worksCitedList","startOfPaperIndex","sectionWorksCited","selectedFormat","setSelectedFormat","firstDoubleQuote_CharValues","lastDoubleQuote_CharValues","selectedFormatHandler","e","preventDefault","value","document","getElementById","inputTextOnChange","responseImportant","innerHTML","style","backgroundColor","inputTextChangeOnBlur","inputText","length","inputTextChangeOnFocus","clearTextArea","stripQuotations","quote","includes","charCodeAt","substring","replace","addToCitationErrorList","citation","secIndex","index","errorMessage","citationObject","i","citationToCheck","getCitation","getCitationObject","citationErrors","getCitationErrors","undefined","push","setCitationErrors","setCitationIndex","setCitationSection","addCitationError","quoteObject","quoteToCheck","getQuote","getQuoteObject","console","log","addCitation","citationStr","setCitation","setCitationError","citationHasErrors","splice","addQuote","quoteErrors","getQuoteErrors","setQuoteErrors","setQuoteIndex","setQuoteSection","addQuoteError","unshift","addDocumentError","documentErrorObject","removeMlaDecimal","word","chars","split","result","slice","capitalizeFirstLetter","charAt","toUpperCase","validateCitationInText","wordsInSection","sentences","join","match","sentencesWithQuotationCitation","sentenceIndex","sentence","hasBeginningQuoteInSentence","hasEndingQuoteInSentence","character","findMlaBlockCitation","startedCitationIndex","findMlaCitations","finalWord","findMlaQuotes","startingIndex","inputSections","currentSection","containsQuoteInSection","containsCitationInSection","hasQuoteErrorInSection","containsQuote","wordsInQuote","wordsinSectionLength","quoteIndex","containsFinalQuote","pop","containsCitation","citationIndex","citationIndexFound","citationRightAfterQuote","citationValid","forEach","error","findMlaWorksCited","totalNumberSections","mlaWorksCitedObj","authorSentence","trim","authorNames","authorErrors","setAuthorIndex","setAuthor","lastNames","firstNames","fullname","toLowerCase","authorAcronym","setAuthorAcronym","errors","getAuthorErrors","setAuthorErrors","insertCommentIntoArray","array","commentType","comment","wordLength","indexToCheck","createSectionsArray","totalNumberOfSections","sectionsArray","sectionIndex","commentsArray","documentErrorObj","getSection","getError","getIndex","getQuoteSection","quoteWordLength","getQuoteIndex","getCitationSection","citationWordLength","getCitationIndex","citationError","worksCitedObject","getSectionIndex","titleSourceErrors","getTitleSourceErrors","titleContainerErrors","getTitleContainerErrors","contributorsErrors","getContributorsErrors","versionErrors","getVersionErrors","publisherErrors","getPublisherErrors","publicationDateErrors","getPublicationDateErrors","locationDateErrors","getLocationErrors","getAuthorIndex","getTitleSourceIndex","getTitleContainerIndex","getContributorsIndex","getVersionIndex","getPublisherIndex","getPublicationDateIndex","getLocationIndex","checkMlaHandler","hasExtraLinesInHeaders","hasMissingHeaders","startParsingIndex","inputHeaders","inputTitle","hasExtraLinesBeforeTitle","text","hasWorksCitedCitations","sectionArrayObject","generateResultPaper","parent","resultsContainer","createElement","classList","add","leftColumnNode","rightColumnNode","resultTitle","resultTitleText","createTextNode","appendChild","commentNumber","sectionNode","sectionArrayComments","commentNumOfItems","tabNode","commentWordLength","commentSpanNode","hasCommentHighlight","wordNode","commentIndex","commentTypeLower","commentNumberNode","numberElement","spaceNode3","containerHeader","commentNumberNode2","numberElement2","commentTypeTextNode","commentTypeElement","append","commentMessageText","commentMessageTextNode","commentMessageNode","commentContainerNode","spaceNode2","spaceNode","checkApaHandler"],"sources":["/usr/share/caddy/personal/formatter/src/App.js"],"sourcesContent":["import './App.css';\nimport {Quote} from './models/Quote.js';\nimport {CitationError} from './models/CitationError.js';\nimport {DocumentError} from './models/DocumentError.js';\nimport {MLAWorksCitation} from './models/MLAWorksCitation.js';\nimport {useState} from 'react';\n\nfunction App() {\n  \n  let documentErrorList;\n  let dataEntriesList;\n  let citationsErrorList;\n  let worksCitedList;\n  let startOfPaperIndex;\n  let sectionWorksCited;\n  const [selectedFormat, setSelectedFormat] = useState(\"MLA\");\n  \n  const firstDoubleQuote_CharValues = [8220, 34];\n  const lastDoubleQuote_CharValues = [8221, 34];\n  // 33: !    46: .    59: ;    63: ?\n  \n  // Need Valid MLA inline-citation\n  \n  function selectedFormatHandler(e) {\n    e.preventDefault();\n    \n    let value = document.getElementById(\"selectedFormat\").value;\n    \n    if (value !== selectedFormat) {\n      if (selectedFormat === \"MLA\") {\n        setSelectedFormat(\"APA\");\n      } else {\n        setSelectedFormat(\"MLA\");\n      }\n    }\n  }\n  \n  function inputTextOnChange(e) {\n    e.preventDefault();\n    \n    const responseImportant = document.getElementById(\"responseImportant\");\n    if (responseImportant.innerHTML === \"Copy and paste your text here\") {\n      responseImportant.innerHTML = \"Click Check Paper!\";\n      responseImportant.style.backgroundColor = \"#ff006a\";\n    }\n  }\n  \n  function inputTextChangeOnBlur(e) {\n    e.preventDefault();\n    \n    let inputText = document.getElementById(\"inputText\").value;\n    \n    if (inputText.length === 0) {\n      const responseImportant = document.getElementById(\"responseImportant\");\n      responseImportant.innerHTML = \"Copy and paste your text here\";\n      responseImportant.style.backgroundColor = \"transparent\";\n    }\n  }\n  \n  function inputTextChangeOnFocus(e) {\n    e.preventDefault();\n    \n    const responseImportant = document.getElementById(\"responseImportant\");\n    if (responseImportant.innerHTML !== \"See results below\") {\n      responseImportant.style.backgroundColor = \"#ff006a\";\n    }\n  }\n  \n  function clearTextArea(e) {\n    e.preventDefault();\n    \n    document.getElementById(\"inputText\").value = \"\";\n    const responseImportant = document.getElementById(\"responseImportant\");\n      responseImportant.innerHTML = \"Copy and paste your text here\";\n    responseImportant.style.backgroundColor = \"transparent\";\n  }\n  \n  function stripQuotations(quote) {\n    if (firstDoubleQuote_CharValues.includes(quote.charCodeAt(0))) {\n      quote = quote.substring(1);\n    }\n    if (lastDoubleQuote_CharValues.includes(quote.charCodeAt(quote.length -1))) {\n      quote = quote.substring(0, (quote.length -1));\n    }\n    quote.replace(\"\\\"\", \"\");\n    \n    return quote;\n  }\n  \n  function addToCitationErrorList(citation, secIndex, index, errorMessage) {\n    let citationObject;\n    \n    for (let i = 0; i < citationsErrorList.length; i++) {\n      let citationToCheck = citationsErrorList[i].getCitation();\n      \n      if (citation === citationToCheck) {\n        citationObject = getCitationObject(citation);\n        let citationErrors = citationObject.getCitationErrors();\n        \n        if (citationErrors === undefined) {\n          citationErrors = [];\n        }\n        \n        citationErrors.push(\"This citation already exists.\");\n        citationObject.setCitationErrors(citationErrors);\n        break;\n      }\n    }\n  \n    if (citationObject === undefined) {\n      citationObject = new CitationError(citation);\n      let citationErrors = [errorMessage];\n      citationObject.setCitationErrors(citationErrors);\n      citationObject.setCitationIndex(index);\n      citationObject.setCitationSection(secIndex);\n    }\n    \n    citationsErrorList.push(citationObject);\n  }\n  \n  function addCitationError(quote, citation, secIndex, index, errorMessage) {\n    quote = stripQuotations(quote);\n    let quoteObject;\n    \n    /* If this is a citation for a quote */\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      \n      if (quote === quoteToCheck) {\n        quoteObject = getQuoteObject(quote);\n        let citationToCheck = quoteObject.getCitation();\n        let citationErrors = quoteObject.getCitationErrors();\n        \n        if (citationErrors === undefined) {\n          citationErrors = [];\n        }\n        \n        if (citation === citationToCheck) {\n          citationErrors.push(\"This citation already exists for given quote.\");\n          // What about errorMessage here?\n          \n        } else {\n          citationErrors.push(errorMessage);\n          \n        }\n        \n        quoteObject.setCitationErrors(errorMessage);\n        dataEntriesList.push(quoteObject);\n        return;\n      }\n    }\n    \n    if (quoteObject === undefined) {\n      console.log(\"Could not add citation error to quotes list.\");\n    }\n    \n  }\n  \n  /* For now, there should only be one quote per citation! This will flip some time soon*/\n  function addCitation(quote, citation, secIndex, index) {\n    quote = stripQuotations(quote);\n    let quoteObject = undefined;\n    \n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      \n      if (quote === quoteToCheck) {\n        quoteObject = getQuoteObject(quote);\n        let citationStr = quoteObject.getCitation();\n        \n        if (citationStr === undefined) {\n          quoteObject.setCitation(citation);\n          quoteObject.setCitationIndex(index);\n          quoteObject.setCitationSection(secIndex);\n          \n        } else {\n          quoteObject.setCitationError(\"This Citation exists at least twice for the quote in this paper.\");\n          addCitationError(quote, citation, secIndex, index);\n        }\n        \n        dataEntriesList.push(quoteObject);\n        break;\n      }\n    }\n    \n    if (quoteObject === undefined) { // If quote does not exists with given citation.\n      let citationHasErrors = false;\n      \n      for (let i = 0; i < citationsErrorList.length; i++) { // Checking to see if has errors\n        let citationToCheck = citationsErrorList[i].getCitation();\n        \n        if (citation === citationToCheck) {\n          citationHasErrors = true;\n          let citationObject = getCitationObject(citation);\n          console.log(citationObject);\n          let citationErrors = citationObject.getCitationErrors();\n          \n          if (citationErrors === undefined) {\n            citationErrors = [];\n          }\n          citationErrors.push(\"This citation is not associated with any quote/block quote.\");\n          citationObject.setCitationErrors(citationErrors);\n          citationsErrorList.push(citationObject);\n          break;\n        }\n      }\n      \n      if (!citationHasErrors) {\n        let citationObject = new CitationError(citation);\n        citationsErrorList.push(citationObject);\n      }\n    }\n    \n  }\n  \n  function getCitationObject(citation) {\n    let citationObject;\n    \n    for (let i = 0; i < citationsErrorList.length; i++) {\n      let citationToCheck = citationsErrorList[i].getCitation();\n      \n      if (citation === citationToCheck) {\n        citationObject = citationsErrorList.splice(i, 1);\n        citationObject = citationObject[0];\n        break;\n      }\n    }\n    return citationObject;\n  }\n  \n  function getQuoteObject(quote) {\n    quote = stripQuotations(quote);\n    let quoteObject;\n    \n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      \n      if (quote === quoteToCheck) {\n        quoteObject = dataEntriesList.splice(i, 1); //Removes the quoteObj from list.\n        quoteObject = quoteObject[0];\n        \n        break;\n      }\n    }\n    return quoteObject;\n  }\n  \n  function addQuote(quote, secIndex, index) {\n    quote = stripQuotations(quote);\n    let quoteObject;\n    \n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      \n      if (quote === quoteToCheck) {\n        quoteObject = getQuoteObject(quote);\n        let quoteErrors = quoteObject.getQuoteErrors();\n        \n        if (quoteErrors === undefined) {\n          quoteErrors = [];\n        }\n        \n        quoteErrors.push(\"This quote already exists in this document\");\n        quoteObject.setQuoteErrors(quoteErrors);\n        break;\n      }\n    }\n    \n    if (quoteObject === undefined) {\n      quoteObject = new Quote(quote);\n      let quoteErrors = [];\n      \n      quoteObject.setQuoteErrors(quoteErrors);\n      quoteObject.setQuoteIndex(index);\n      quoteObject.setQuoteSection(secIndex);\n    }\n    \n    dataEntriesList.push(quoteObject);\n  }\n  \n  function addQuoteError(quote, errorMessage) {\n    quote = stripQuotations(quote);\n    \n    let quoteObject = getQuoteObject(quote);\n    \n    if (quoteObject === undefined) {\n      console.log(\"SYSTEM ERROR: Cannot add error to a quote that does not exist\");\n      return undefined;\n    }\n    \n    let quoteErrors = quoteObject.getQuoteErrors();\n    if (quoteErrors === undefined) {\n      quoteErrors = [];\n    }\n    \n    quoteErrors.push(errorMessage);\n    quoteObject.setQuoteErrors(quoteErrors);\n    \n    dataEntriesList.unshift(quoteObject);\n  }\n  \n  function addDocumentError(errorMessage, secIndex, index) {\n    let documentErrorObject = new DocumentError(errorMessage, secIndex, index);\n    documentErrorList.push(documentErrorObject);\n  }\n  \n  function removeMlaDecimal(word) {\n    const chars = word.split('');\n    if (chars[(word.length-1)] === '.') { // If the last character is a decimal, remove it!\n      const result = word.slice(0, -1);\n      return result;\n    } else {\n      return word;\n    }\n  }\n  \n  function capitalizeFirstLetter(word) {\n    return word.charAt(0).toUpperCase() + word.slice(1);\n  }\n  \n  /** This should check that an author's name appears in here! Author must come from Works Cited list*/\n  function validateCitationInText(wordsInSection, citation) {\n    // DO NOT disable the comment below...\n    // eslint-disable-next-line\n    let sentences = wordsInSection.join(\" \").match( /[^\\.!\\?]+[\\.!\\?]+/g );\n    \n    let sentencesWithQuotationCitation = [];\n    // console.log(\"Citation to check: \" +citation);\n    \n    for (let sentenceIndex = 0; sentenceIndex < wordsInSection.length; sentenceIndex++) {\n      let sentence = sentences[sentenceIndex];\n      let hasBeginningQuoteInSentence = false;\n      let hasEndingQuoteInSentence = false;\n      \n      if (sentence === undefined) {\n        continue;\n      }\n      \n      for (let i = 0; i < sentence.length; i++) {\n        let character = sentence[i];\n        \n        if (!hasBeginningQuoteInSentence && firstDoubleQuote_CharValues.includes(character.charCodeAt(0))) {\n          hasBeginningQuoteInSentence = true;\n          \n        } else if (!hasEndingQuoteInSentence && lastDoubleQuote_CharValues.includes(character.charCodeAt(0))) {\n          hasEndingQuoteInSentence = true;\n          // console.log(\"Sentence: \"+sentence);\n          break;\n          \n        }\n        \n      }\n      \n      if (hasBeginningQuoteInSentence) {\n        sentencesWithQuotationCitation.push(sentence);\n        // console.log(\"Has beginning quote! \" +sentencesWithQuotationCitation.join(\" \"));\n        // console.log(sentencesWithQuotationCitation.join(\" \").includes(citation));\n      \n        if (hasEndingQuoteInSentence) { // IF IT HAS ENDING QUOTATION MARKS, THE CITATION MUST EXIST AFTER QUOTE!\n          // console.log(\"Quote found! \" +sentencesWithQuotationCitation.join(\" \"));\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  \n  function findMlaBlockCitation(wordsInSection, secIndex) {\n    \n    if (wordsInSection.join(\" \").includes(\")\") && wordsInSection.join(\" \").includes(\"(\")) { // Checks if the section contains a parenthesis. Possible block citation!\n      console.log(wordsInSection);\n      let citation = [];\n      let quote = [];\n      let i = 0;\n      let startedCitationIndex = 0;\n    \n      while (true) {\n        let word = wordsInSection[i];\n        \n        citation = findMlaCitations(word, startedCitationIndex, i, citation);\n        \n        if (citation[0].includes(\")\") && citation[0].includes(\"(\")) { // If citation was found\n          addQuote(quote.join(\" \"), secIndex, 0);\n          addCitation(quote.join(\" \"), citation.join(\" \"), secIndex, i);\n          return true;\n          \n        } else if (!citation[0].includes(\"(\")) {\n          quote.push(word);\n        } else if (citation[0].includes(\"(\")) {\n          citation.push(word);\n        }\n        \n        i++;\n      }\n    }\n    return false;\n  }\n  \n  function findMlaCitations(word, startedCitationIndex, i, citation) {\n    \n    if (!word.includes(\"(\") && (citation === undefined)) { // If beginning of citation and doesn't include open parenthesis.\n      console.log(\"Citation does not come right after quote! WHOOPS\");\n      return [];\n      \n    } else if (word.includes(\"(\") && (startedCitationIndex === i)) { // If citation is right after quote.\n      \n      if (word.includes(\")\")) { // If word is also end of citation too.\n        const finalWord = removeMlaDecimal(word);\n        citation.push(finalWord);\n        return [citation.join(\" \")];\n      }\n      citation.push(word);\n      \n    } else if (word.includes(\")\")) { // If this is the end of the citation.\n      const finalWord = removeMlaDecimal(word);\n      citation.push(finalWord);\n      return [citation.join(\" \")];\n      \n    } else {\n      citation.push(word);\n    }\n    \n    return [citation.join(\" \")];\n  }\n  \n  /**\n   * Finds all of the quotes in MLA Format and adds them to the Quotes List! \n   */\n  function findMlaQuotes(startingIndex, inputSections, sectionWorksCited) {\n    \n    for (let secIndex = startingIndex; secIndex < sectionWorksCited; secIndex++) {\n      let currentSection = inputSections[secIndex].replace('\\t', \"\");\n      const wordsInSection = currentSection.split(\" \");\n      \n      if (wordsInSection.length < 2) { // We don't want empty sections!\n        continue;\n      }\n      \n      let containsQuoteInSection = false;\n      let containsCitationInSection = false;\n      let hasQuoteErrorInSection = false;\n      \n      /* Time to find the quotes in a section*/\n      for (let i = 0; i < wordsInSection.length; i++) {\n        let word = wordsInSection[i];\n        \n        let containsQuote = false;\n        let quote;\n        let quoteErrors = [];\n        let citationErrors = [];\n        \n        if (firstDoubleQuote_CharValues.includes(word.charCodeAt(0))) { // First quoted word found, now find the last.\n          let wordsInQuote = [];\n          wordsInQuote.push(word);\n          let wordsinSectionLength = wordsInSection.length -1;\n          let quoteIndex = i;\n          \n          while (true) { // Checking word with ending quotation marks!\n            i++;\n            word = wordsInSection[i];\n            \n            word = removeMlaDecimal(word);\n            \n            const containsFinalQuote = (lastDoubleQuote_CharValues.includes(word.charCodeAt(word.length -1)));\n            wordsInQuote.push(word);\n            \n            if (containsFinalQuote) {\n              containsQuoteInSection = true;\n              containsQuote = true;\n              break;\n            } else if (word.includes(\"(\")) { // If a citation comes before an ending parenthesis, tell the user.\n              quoteErrors.push(\"Missing ending parenthesis. Is it possible that you missed one before the citation?\");\n              wordsInQuote.pop();\n              hasQuoteErrorInSection = true;\n              containsQuote = true;\n              break;\n            } else if (i === wordsinSectionLength) { // If this is the last word in the section and doesn't contain any quotes, tell the user.\n              quoteErrors.push(\"Missing ending quotation marks!\");\n              hasQuoteErrorInSection = true;\n              containsQuote = true;\n              break;\n            }\n          }\n          \n          quote = wordsInQuote.join(\" \");\n          \n          let startedCitationIndex = i+1;\n          let containsCitation = false;\n          let citation = [];\n          let citationIndex = 0;\n          let citationIndexFound = false;\n          let citationRightAfterQuote = true;\n          \n          // Get the citing of the quote after the quotation marks.\n          while (true) {\n            i++;\n            if (wordsInSection.length === i) {\n              break;\n            }\n            word = wordsInSection[i];\n            \n            \n            if (firstDoubleQuote_CharValues.includes(word.charCodeAt(0))) { // Could mean that this quote could be associated with the next quote?\n              i--;\n              break;\n            }\n            \n            citation = findMlaCitations(word, startedCitationIndex, i, citation);\n            \n            /* If citation hasn't been found yet, give it the index now that it's found!*/\n            if (!citationIndexFound && citation[0].includes(\"(\")) {\n              citationIndexFound = true;\n              citationIndex = i;\n              continue;\n            }\n            \n            /* If the citation index isn't found yet and it's not the last word in the section, continue to next iteration*/\n            if (containsQuote && !citationIndexFound && (i !== wordsInSection.length -1)) {\n              citationRightAfterQuote = false;\n              citation.splice(0, citation.length);\n              continue;\n            }\n            \n            \n            if (citation[0].includes(\")\") && citation[0].includes(\"(\")) { // If citation was found\n              containsCitationInSection = true;\n              containsCitation = true;\n              break;\n            }\n          }\n          \n          if (containsCitation) {\n            citation = citation.join(\" \");\n          }\n          \n          /* If there's a quote where the citation doesn't come right after. Suggestion! */\n          if (!citationRightAfterQuote && containsQuote) {\n            citationErrors.push(\"Suggestion: add citation directly after the quote.\");\n          }\n          \n          /* If there's a citation and a quote! */\n          if (containsCitation && containsQuote) {\n            \n            addQuote(quote, secIndex, quoteIndex);\n            addCitation(quote, citation, secIndex, citationIndex);\n            \n            // Validate citation\n            let citationValid = validateCitationInText(wordsInSection, citation);\n            if (!citationValid) {\n              \n            }\n            \n          } else if (containsCitation && !containsQuote) { // If there's only a citation\n            addToCitationErrorList(citation, \"No quote exists for the given citation\");\n            \n          } else if (!containsCitation && containsQuote) { // If there's only a quote\n            // Could be a quote from different paragraph? Idk...\n            addQuote(quote, secIndex, quoteIndex);\n            // let quoteLength = quote.length;\n            // addCitationError(quote, )\n            addQuoteError(quote, \"This quote does not have an in-text citation\");\n          }\n          \n          if (containsQuote && quoteErrors !== undefined) {\n            quoteErrors.forEach(error => {\n              addQuoteError(quote, error);\n            });\n          }\n          \n          if (containsCitation && citationErrors !== undefined) {\n            citationErrors.forEach(error => {\n              addToCitationErrorList(citation, secIndex, citationIndex, error);\n            });\n          }\n          \n          //Repeat for multiple quotes/citations in paragraph.\n        }\n      }\n    \n      if (!containsQuoteInSection && !hasQuoteErrorInSection) { // If the section does not contain a quote in section or quote errors. Could it be a block citation?\n        containsCitationInSection = findMlaBlockCitation(wordsInSection, secIndex);\n      }\n      \n      if (containsQuoteInSection && !containsCitationInSection) { // This could possibly be a single cited paper!\n        \n      }\n      \n      if (!containsCitationInSection && !containsQuoteInSection) {\n        addDocumentError(\"No quote or citation exists for this paragraph!\", secIndex, 0);\n      }\n    }\n  }\n  \n  /**\n  * Author, Title of source, Title of container, Other contributors\n  * Version, Number, Publisher, Publication date, Location.\n  */\n  function findMlaWorksCited(sectionWorksCited, inputSections, totalNumberSections) {\n    \n    for (let secIndex = sectionWorksCited; secIndex < totalNumberSections; secIndex++) {\n      let mlaWorksCitedObj = new MLAWorksCitation(inputSections[secIndex], secIndex);\n      // DO NOT disable the comment below...\n      // eslint-disable-next-line\n      let sentences = inputSections[secIndex].match( /[^\\.!\\?]+[\\.!\\?]+/g );\n      // for (let sentIndex = 0; sentIndex < sentences.length)\n      let sentenceIndex = 0;\n      \n      if (sentences === null) { // This is null instead of undefined because of the funky .match() function above.\n        addDocumentError(\"Add your works citations at the end of the paper under the Works Cited section!\", secIndex, 0);\n        return;\n      }\n      \n      /* Find Author and Author Acronym! */\n      let authorSentence = sentences[sentenceIndex].trim();\n      authorSentence = authorSentence.replace('.', \"\");\n      \n      // console.log(authorSentence);\n      // console.log(secIndex);\n      // if (authorSentence)\n      let authorNames = authorSentence.split(\",\");\n      let authorErrors = [];\n      \n      if (authorNames === undefined) {\n        addDocumentError(\"Add your works citations at the end of the paper under the Works Cited section!\", secIndex, 0);\n        return;\n      }\n      \n      mlaWorksCitedObj.setAuthorIndex(sentenceIndex);\n      \n      // console.log(authorNames);\n      if (authorNames.length === 1) {\n        mlaWorksCitedObj.setAuthor(authorNames[0]);\n        authorErrors.push(\"Author name must include first and last name in the following format\" +\n        \" 'Last Name, First Name (Optional: Middle Initial/Name).'\");\n      } else if (authorNames.length > 2) {\n        mlaWorksCitedObj.setAuthor(authorSentence);\n        authorErrors.push(\"Make sure to use the following format for the Author's name:\" +\n        \" 'Last Name, First Name (Optional: Middle Initial/Name).'\");\n      } else {\n        let lastNames = authorNames[0].trim().split(\" \");\n        let firstNames = authorNames[1].trim().split(\" \");\n        let fullname = [];\n        \n        firstNames.forEach(word => {\n          fullname.push(capitalizeFirstLetter(word.toLowerCase()));\n        });\n        lastNames.forEach(word => {\n          fullname.push(capitalizeFirstLetter(word.toLowerCase()));\n        });\n        \n        mlaWorksCitedObj.setAuthor(fullname.join(\" \"));\n        \n        let authorAcronym = [];\n        firstNames.forEach(word => {\n          authorAcronym.push(word.charAt(0));\n        });\n        lastNames.forEach(word => {\n          authorAcronym.push(word.charAt(0));\n        });\n        \n        mlaWorksCitedObj.setAuthorAcronym(authorAcronym.join(\"\"));\n        // console.log(authorAcronym);\n        // console.log(firstNames);\n        // console.log(lastNames);\n      }\n      \n      if (authorErrors !== undefined) {\n        let errors = mlaWorksCitedObj.getAuthorErrors();\n        \n        if (errors === undefined) {\n          errors = [];\n        }\n        authorErrors.forEach(error => {\n          errors.push(error);\n        });\n        \n        mlaWorksCitedObj.setAuthorErrors(errors);\n      }\n      \n      \n      \n      \n      sentenceIndex += 1;\n      /*   */\n      \n      worksCitedList.push(mlaWorksCitedObj);\n      \n    }\n    \n    if (worksCitedList[0] === undefined) {\n      return false;\n    }\n    \n    return true;\n  }\n  \n  function insertCommentIntoArray(array, index, commentType, comment, wordLength) {\n    if (array.length < 2) {\n      array.push(index);\n      array.push(commentType);\n      array.push(comment);\n      array.push(wordLength);\n      return array;\n    }\n    \n    for (let i = 0; i < array.length; i+=4) {\n      let indexToCheck = array[i];\n      \n      if (index <= indexToCheck) {\n        array.splice(i, 0, wordLength);\n        array.splice(i, 0, comment);\n        array.splice(i, 0, commentType);\n        array.splice(i, 0, index);\n        return array;\n      }\n    }\n    \n    array.push(index);\n    array.push(commentType);\n    array.push(comment);\n    array.push(wordLength);\n    return array;\n  }\n  \n  /* Creates an array that holds indexes with errors/suggestions/correct statements for printing! */\n  function createSectionsArray(totalNumberOfSections) {\n    let sectionsArray = [];\n    \n    for (let sectionIndex = 0; sectionIndex < totalNumberOfSections; sectionIndex++) {\n      let commentsArray = []; // The index & comment to the error!\n      \n      /* Documents List! */\n      documentErrorList.forEach(documentErrorObj => {\n        if (documentErrorObj.getSection() === sectionIndex) {\n          let error = documentErrorObj.getError();\n          commentsArray = insertCommentIntoArray(commentsArray, documentErrorObj.getIndex(), \"Document Error\", error, 0);\n        }\n      });\n      \n      /* Quotes/Citations List! */\n      dataEntriesList.forEach(quoteObject => {\n        // Quotes \n        if (quoteObject.getQuoteSection() === sectionIndex) {\n          let quoteWordLength = quoteObject.getQuote().split(\" \").length;\n          let errors = quoteObject.getQuoteErrors();\n          if (errors === undefined) { // There should always be quote errors... for some reason :D\n            return;\n          }\n          \n          if (errors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, quoteObject.getQuoteIndex(), \"Valid Quotation\", \"Correct quote format!\", quoteWordLength);\n          } else {\n            \n            for (let i = 0; i < errors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, quoteObject.getQuoteIndex(), \"Quotation Error\", errors[i], quoteWordLength);\n            }\n            \n          }\n        }\n        \n        \n        // Citations\n        if (quoteObject.getCitationSection() !== undefined && quoteObject.getCitationSection() === sectionIndex) {\n          let citationWordLength = quoteObject.getCitation().split(\" \").length;\n          let errors = quoteObject.getCitationErrors();\n          \n          if (errors === undefined || errors.length < 1) { // If there aren't any errors\n            commentsArray = insertCommentIntoArray(commentsArray, quoteObject.getCitationIndex(), \"Valid Citation\", \"Correct Citation.\", citationWordLength);\n          } else {\n            \n            for (let i = 0; i < errors.length; i++) { // insert each error!\n              commentsArray = insertCommentIntoArray(commentsArray, quoteObject.getCitationIndex(), \"Citation Error\", errors[i], citationWordLength);\n            }\n            \n          }\n        }\n      });\n      \n      /* Citation Errors List! */\n      citationsErrorList.forEach(citationError => {\n        console.log(citationError.getCitationSection() === sectionIndex);\n        if (citationError.getCitationSection() === sectionIndex) {\n          let errors = citationError.getCitationErrors();\n          \n          if (errors === undefined) {\n            console.log(\"SYSTEM ERROR: citation error must include error message.\");\n            return;\n          }\n          for (let i = 0; i < errors.length; i++) {\n            let wordLength = citationError.getCitation().split(\" \").length;\n            console.log(errors[i]);\n            commentsArray = insertCommentIntoArray(commentsArray, citationError.getCitationIndex(), \"Citation Error\", errors[i], wordLength);\n          }\n        }\n      });\n      \n      /* Works Cited List! */\n      worksCitedList.forEach(worksCitedObject => {\n        if (worksCitedObject.getSectionIndex() === sectionIndex) {\n          let authorErrors = worksCitedObject.getAuthorErrors();\n          let titleSourceErrors = worksCitedObject.getTitleSourceErrors();\n          let titleContainerErrors = worksCitedObject.getTitleContainerErrors();\n          let contributorsErrors = worksCitedObject.getContributorsErrors();\n          let versionErrors = worksCitedObject.getVersionErrors();\n          let publisherErrors = worksCitedObject.getPublisherErrors();\n          let publicationDateErrors = worksCitedObject.getPublicationDateErrors();\n          let locationDateErrors = worksCitedObject.getLocationErrors();\n          \n          if (authorErrors === undefined || authorErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getAuthorIndex(), \"Valid Author\", \"Correct Author format.\", 0);\n          } else {\n            for (let i = 0; i < authorErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getAuthorIndex(), \"Invalid Author\", authorErrors[i], 0);\n            }\n          }\n          \n          if (titleSourceErrors === undefined || titleSourceErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getTitleSourceIndex(), \"Valid Title Source\", \"Correct Title Source format.\", 0);\n          } else {\n            for (let i = 0; i < titleSourceErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getTitleSourceIndex(), \"Invalid Title Source\", titleSourceErrors[i]);\n            }\n          }\n          \n          if (titleContainerErrors === undefined || titleContainerErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getTitleContainerIndex(), \"Valid Title Container\", \"Correct Title Container format.\", 0);\n          } else {\n            for (let i = 0; i < titleContainerErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getTitleContainerIndex(), \"Invalid Title Container\", titleContainerErrors[i], 0);\n            }\n          }\n          \n          if (contributorsErrors === undefined || contributorsErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getContributorsIndex(), \"Valid Contributors\", \"Correct Contributor format.\", 0);\n          } else {\n            for (let i = 0; i < contributorsErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getContributorsIndex(), \"Invalid Contributors\", contributorsErrors[i], 0);\n            }\n          }\n          \n          \n          if (versionErrors === undefined || versionErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getVersionIndex(), \"Valid Version\", \"Correct Version format.\", 0);\n          } else {\n            for (let i = 0; i < versionErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getVersionIndex(), \"Invalid Version\", versionErrors[i], 0);\n            }\n          }\n          \n          if (publisherErrors === undefined || publisherErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getPublisherIndex(), \"Valid Publisher\", \"Correct Publisher format.\", 0);\n          } else {\n            for (let i = 0; i < publisherErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getPublisherIndex(), \"Invalid Publisher\", publisherErrors[i], 0);\n            }\n          }\n          \n          if (publicationDateErrors === undefined || publicationDateErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getPublicationDateIndex(), \"Valid Publication Date\", \"Correct Publicatoin Date format.\", 0);\n          } else {\n            for (let i = 0; i < publicationDateErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getPublicationDateIndex(), \"Invalid Publication Date\", publicationDateErrors[i], 0);\n            }\n          }\n          \n          if (locationDateErrors === undefined || locationDateErrors.length < 1) {\n            commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getLocationIndex(), \"Valid Location\", \"Correct Location format.\", 0);\n          } else {\n            for (let i = 0; i < locationDateErrors.length; i++) {\n              commentsArray = insertCommentIntoArray(commentsArray, worksCitedObject.getLocationIndex(), \"Invalid Location\", locationDateErrors[i], 0);\n            }\n          }\n          \n        }\n      });\n      \n      sectionsArray.push(commentsArray);\n    }\n    \n    return sectionsArray;\n  }\n  \n  function checkMlaHandler(e) {\n    e.preventDefault();\n    documentErrorList = [];\n    citationsErrorList = [];\n    dataEntriesList = [];\n    worksCitedList = [];\n    \n    const responseImportant = document.getElementById(\"responseImportant\");\n    responseImportant.innerHTML = \"\";\n    \n    const inputText = document.getElementById(\"inputText\").value;\n    \n    if (inputText.length > 0) {\n      responseImportant.style.backgroundColor = \"#FF006A\";\n      // responseImportant.style.color = \"#FFF\";\n    }\n    \n    let inputSections = inputText.split(\"\\n\");\n    if (inputSections.length <= 1) {\n      \n      if (inputSections[0].length > 1) {\n        responseImportant.innerHTML = \"Make sure you've copied your whole paper before checking! \" +\n        \"Include the following headers: Full Name, Teacher, Class Name, Today's Date.\";\n        return;\n      }\n      \n      responseImportant.innerHTML = \"Copy and paste your paper to start!\";\n      return;\n    }\n\n    /* Parse the headers! */\n    let hasExtraLinesInHeaders = false;\n    let hasMissingHeaders = false;\n    let startParsingIndex = 0;\n    let inputHeaders = [];\n    for (let i = 0; i < inputSections.length; i++) {\n      \n      if (inputSections[i].length < 1) {\n        hasExtraLinesInHeaders = true;\n        inputSections.splice(i, 1);\n        i--;\n      } else if (inputSections[i].length > 15) {\n        hasMissingHeaders = true;\n        break;\n      } else {\n        inputHeaders.push(inputSections[i]);\n      }\n      \n      if (inputHeaders !== undefined && inputHeaders.length === 4) {\n        break;\n      }\n    }\n\n    /* Input Headers handling!! */\n    if (inputHeaders === undefined) {\n      responseImportant.innerHTML = \"his paper is empty\";\n      return;\n    } else if (inputHeaders.length < 4) {\n      addDocumentError(\"Missing headers! Headers must include: your name, your teacher's name, class name, and current date.\", 0, 0);\n    }\n    if (hasExtraLinesInHeaders) {\n      addDocumentError(\"Consider removing the extra lines between headers of your document.\", 0, 0);\n    }\n    if (hasMissingHeaders) {\n      addDocumentError(\"Header/Title is missing! Headers must include: your name, your teacher's name, class name, and current date.\" +\n      \"If your title is over 15 words long, shorten it and click the Check Citation button again.\", 0, 0);\n    }\n    \n    /* Parse up until the Title! */\n    let inputTitle;\n    let hasExtraLinesBeforeTitle = false;\n    for (let i = inputHeaders.length; i < inputSections.length; i++) {\n      \n      if (inputSections[i].length < 2) {\n        hasExtraLinesBeforeTitle = true;\n        inputSections.splice(i, 1);\n        i--;\n      } else {\n        inputTitle = inputSections[i];\n        startParsingIndex = i+1;\n        break;\n      }\n    }\n    \n    /* Title Handling */\n    if (inputTitle === undefined) {\n      responseImportant.innerHTML = \"Please add more to your paper before checking!\";\n      return;\n    }\n    if (inputSections[startParsingIndex].length < 2 || hasExtraLinesBeforeTitle) {\n      addDocumentError(\"Consider removing the extra lines before and after the Title of your document.\", startParsingIndex -1, 0);\n    }\n    \n    /* Parse the extra lines after the Title! We don't want to use them :) */\n    for (let i = startParsingIndex; i < inputSections.length; i++) {\n      if (inputSections[i].length < 2) {\n        inputSections.splice(i, 1);\n        i--;\n      }\n    }\n    \n    /* Removing any extra lines in the document.*/\n    startOfPaperIndex = undefined;\n    for (let i = 0; i < inputSections.length; i++) {\n      if (inputSections[i].length < 2) {\n        inputSections.splice(i, 1);\n        i--;\n      } else if (startOfPaperIndex === undefined && inputSections[i].split(\" \").length > 20) {\n        startOfPaperIndex = i;\n        break;\n      }\n    }\n    \n    if (startOfPaperIndex === undefined) {\n      responseImportant.innerHTML = \"Please add more to your paper before checking!\";\n      return;\n    }\n    \n    sectionWorksCited = undefined; \n    /* Give the section works cited the last section so the loop can work. */\n    for (let i = startParsingIndex; i < inputSections.length; i++) {\n      let text = inputSections[i].trim().split(\" \");\n      if (text.length === 2) {\n        text = text.join(\" \").toLowerCase();\n        if (text === \"works cited\" || text === \"references\" || text === \"bibliography\") {\n          sectionWorksCited = i;\n        }\n      }\n    }\n    \n    if (sectionWorksCited === undefined) {\n      sectionWorksCited = inputSections.length;\n      responseImportant.innerHTML = \"Please include a works cited page at the end of your document. If your works cited page exists,\" +\n      \" make sure to have a single line named 'Works Cited' before the citations\";\n      return;\n    }\n    \n    /* Check for MLA Works Cited page and parse the works cited citations!*/\n    let hasWorksCitedCitations = false;\n    if (sectionWorksCited < inputSections.length) {\n      hasWorksCitedCitations = findMlaWorksCited(sectionWorksCited+1, inputSections, inputSections.length);\n    }\n    \n    if (!hasWorksCitedCitations) {\n      responseImportant.innerHTML = \"Add your source citations under your 'Works Cited' section at the end of the document.\";\n      return;\n    }\n    \n    // console.log(inputSections);\n    // console.log(startOfPaperIndex, sectionWorksCited);\n    \n    /* Now find the in-text quotes/citations inside the paper sections!*/\n    findMlaQuotes(startOfPaperIndex, inputSections, sectionWorksCited);\n    \n    /* Check that citations alone are valid */\n    \n    \n    // console.log(dataEntriesList);\n    // console.log(citationsErrorList);\n    // console.log(worksCitedList);\n    // console.log(documentErrorList);\n    \n    \n    const sectionArrayObject = createSectionsArray(inputSections.length);\n    console.log(sectionArrayObject);\n    \n    generateResultPaper(sectionArrayObject, inputSections);\n    \n    console.log(\"\\nEND\\n\\n\");\n    responseImportant.innerHTML = \"See results below\";\n    responseImportant.style.backgroundColor = \"#3CD604\";\n  }\n  \n  function generateResultPaper(sectionArrayObject, inputSections) {\n        /* Creating container for parent node */\n    const parent = document.getElementById(\"bottom-parent\");\n    parent.innerHTML = ''; // Clear previous results!\n    const resultsContainer = document.createElement(\"div\");\n    resultsContainer.classList.add(\"container-other\");\n    \n    /* Creating side comment column nodes */\n    const leftColumnNode = document.createElement(\"div\");\n    leftColumnNode.classList.add(\"container-other\");\n    leftColumnNode.classList.add(\"left-column\");\n    const rightColumnNode = document.createElement(\"div\");\n    rightColumnNode.classList.add(\"container-other\");\n    rightColumnNode.classList.add(\"right-column\");\n    \n    \n    /* Creating results container so text nodes can be appended inside of the container */\n    const resultTitle = document.createElement(\"h1\");\n    const resultTitleText = document.createTextNode(\"Results\");\n    resultTitle.appendChild(resultTitleText);\n    resultsContainer.appendChild(resultTitle);\n    \n    \n    // let userOnlyErrors = false; // Based off of input\n    let commentNumber = 1;\n    /* Start creating the paper! parent -> resultsContainer -> text */\n    for (let secIndex = 0; secIndex < inputSections.length; secIndex++) {\n      const wordsInSection = inputSections[secIndex].split(\" \");\n      const sectionNode = document.createElement(\"p\");\n      \n      const sectionArrayComments = sectionArrayObject[secIndex];\n      const commentNumOfItems = sectionArrayComments.length;\n      \n      if (secIndex >= startOfPaperIndex && secIndex < sectionWorksCited) { // To tab paragraphs!\n        const tabNode = document.createTextNode(\"\\u00a0\\u00a0\\u00a0\\u00a0\");\n        sectionNode.appendChild(tabNode);\n      }\n      \n      let commentWordLength = 0;\n      let commentSpanNode;\n      let hasCommentHighlight = false;\n      for (let i = 0; i < wordsInSection.length; i++) {\n        const word = wordsInSection[i];\n        // const spanNode = document.createElement(\"span\");\n        const wordNode = document.createTextNode(word);\n        \n        for (let commentIndex = 0; commentIndex < commentNumOfItems; commentIndex+=4) {\n          \n          if (i === sectionArrayComments[commentIndex]) {\n            // console.log(secIndex + \" \" + sectionArrayComments[commentIndex]);\n            const commentType = sectionArrayComments[commentIndex+1];\n            const commentTypeLower = commentType.toLowerCase();\n            \n            // if (userOnlyErrors || (!commentTypeLower.includes(\"error\") || !commentTypeLower.includes(\"invalid\"))) {\n            //   continue;\n            // }\n            \n            /** Determines how to highlight the text in the paper*/\n            if (commentWordLength === 0 && !hasCommentHighlight) {\n              hasCommentHighlight = true;\n              commentWordLength = sectionArrayComments[commentIndex + 3];\n              commentSpanNode = document.createElement(\"span\");\n              \n              if (commentTypeLower.includes(\"error\") || commentTypeLower.includes(\"invalid\")) {\n                commentSpanNode.classList.add(\"red-text\");\n              } else if (commentTypeLower.includes(\"valid\")) {\n                commentSpanNode.classList.add(\"green-text\");\n              } else if (commentTypeLower.includes(\"suggestion\")) {\n                commentSpanNode.classList.add(\"yellow-text\");\n              }\n            }\n            \n            const commentNumberNode = document.createTextNode(commentNumber);\n            const numberElement = document.createElement(\"span\");\n            \n            if (commentTypeLower.includes(\"error\") || commentTypeLower.includes(\"invalid\")) {\n              numberElement.classList.add(\"red-number\");\n            } else if (commentTypeLower.includes(\"valid\")) {\n              numberElement.classList.add(\"green-number\");\n            } else if (commentTypeLower.includes(\"suggestion\")) {\n              numberElement.classList.add(\"yellow-number\");\n            }\n            \n            numberElement.appendChild(commentNumberNode);\n            sectionNode.appendChild(numberElement);\n            let spaceNode3 = document.createTextNode(\" \");\n            sectionNode.appendChild(spaceNode3);\n            \n            \n            /** USE #2\n            * Create this or the textnodes/nodes from above will be placed over the nodes below in the Paper! \n            */\n            const containerHeader = document.createElement(\"div\");\n            containerHeader.classList.add(\"side-container-header\");\n            \n            const commentNumberNode2 = document.createTextNode(commentNumber);\n            const numberElement2 = document.createElement(\"span\");\n            \n            if (commentTypeLower.includes(\"error\") || commentTypeLower.includes(\"invalid\")) {\n              numberElement2.classList.add(\"red-number\");\n            } else if (commentTypeLower.includes(\"valid\") && !commentTypeLower.includes(\"invalid\")) {\n              numberElement2.classList.add(\"green-number\");\n            } else if (commentTypeLower.includes(\"suggestion\")) {\n              numberElement2.classList.add(\"yellow-number\");\n            }\n            \n            numberElement2.appendChild(commentNumberNode2);\n            \n            /* Comment Type Node */\n            const commentTypeTextNode = document.createTextNode(commentType);\n            const commentTypeElement = document.createElement(\"h3\");\n            commentTypeElement.append(commentTypeTextNode);\n            \n            /* Comment Message Node */\n            const commentMessageText = sectionArrayComments[commentIndex+2];\n            const commentMessageTextNode = document.createTextNode(commentMessageText);\n            const commentMessageNode = document.createElement(\"p\");\n            commentMessageNode.appendChild(commentMessageTextNode);\n            \n            /* Comment Container Node */\n            const commentContainerNode = document.createElement(\"div\");\n            commentContainerNode.classList.add(\"side-container\");\n            \n            /** Append comment number and type Comment Header div.\n            * Then append Comment Header div to Comment Container div.\n            */\n            containerHeader.appendChild(numberElement2);\n            containerHeader.appendChild(commentTypeElement);\n            commentContainerNode.appendChild(containerHeader);\n            commentContainerNode.appendChild(commentMessageNode);\n            \n            /* If comment number is even, append it to right side. Else, left side.*/\n            if (commentNumber % 2 === 0) {\n              rightColumnNode.appendChild(commentContainerNode);\n            } else {\n              leftColumnNode.appendChild(commentContainerNode);\n            }\n            \n            \n            commentNumber += 1;\n          }\n        }\n        \n        /* If there is a comment associated with the word, make sure the word is added to a highlighted span */\n        if (commentWordLength > 0) {\n          commentWordLength -= 1;\n          \n          commentSpanNode.appendChild(wordNode);\n          const spaceNode2 = document.createTextNode(\" \");\n          commentSpanNode.appendChild(spaceNode2);\n          \n          /* If this is the last word in the highlight. */\n          if (commentWordLength === 0) {\n            hasCommentHighlight = false;\n            sectionNode.appendChild(commentSpanNode);\n          }\n          \n        } else { // Else, just add it to the section node\n          sectionNode.appendChild(wordNode);\n          const spaceNode = document.createTextNode(\" \");\n          sectionNode.appendChild(spaceNode);\n          \n        }\n      } \n      \n      resultsContainer.append(sectionNode);\n    }\n    \n    // const results = document.createElement(\"div\");\n    // resultsContainer.appendChild(results);\n    \n    \n    /* Add the results container at the end! */\n    parent.appendChild(leftColumnNode);\n    parent.appendChild(resultsContainer);\n    parent.appendChild(rightColumnNode);\n  }\n  \n  function checkApaHandler(e) {\n    e.preventDefault();\n  }\n  \n  return (\n    <div id=\"parent\" className=\"App\">\n      <div id=\"header\" className=\"header\"></div>\n      <div className=\"container\">\n        <h1>Essay Format Checker</h1>\n        <form className=\"inputForm\" autoComplete=\"off\">\n          <div className=\"input-field\">\n            <textarea onChange={inputTextOnChange} onBlur={inputTextChangeOnBlur} onFocus={inputTextChangeOnFocus} id=\"inputText\" type=\"text\" required/>\n            <label id=\"responseImportant\">Copy and paste your text here</label>\n            <span></span>\n          </div>\n          <div className=\"bottom-row\">\n            <div className=\"importantButtons\">\n            { selectedFormat === \"MLA\" ?\n              <button onClick={checkMlaHandler} type=\"submit\" value=\"Check Paper\" className=\"btn btn-check\">Check for MLA format</button>\n              :\n              <button onClick={checkApaHandler} type=\"submit\" value=\"Check Paper\" className=\"btn btn-check\">Check for APA format</button>\n            }\n              <select onChange={selectedFormatHandler} id=\"selectedFormat\" name=\"inputFormat\" className=\"btn btn-select\">\n                <option value=\"MLA\">MLA</option>\n                <option value=\"APA\">APA</option>\n              </select>\n            </div>\n            <button onClick={clearTextArea} type=\"submit\" value=\"Clear\" className=\"btn btn-clear\">Clear</button>\n          </div>\n        </form>\n      </div>\n      \n      <div id=\"bottom-parent\" className=\"bottom-parent\">\n      </div>\n      \n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}