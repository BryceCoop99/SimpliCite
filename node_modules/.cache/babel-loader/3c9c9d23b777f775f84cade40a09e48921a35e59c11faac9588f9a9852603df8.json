{"ast":null,"code":"var _jsxFileName = \"/usr/share/caddy/personal/formatter/src/App.js\";\nimport './App.css';\nimport { Quote } from './models/Quote.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  /* [{Quote: [[{Citation: [Citation Errors]}], [Quote Errors]]}, {...}, ...]*/\n  /**\n  Errors: documentErrors, intextErrors, worksCitedErrors.\n  \n  */\n  let documentErrorList;\n  let dataEntriesList;\n  let citationsErrorList;\n  const firstDoubleQuote_CharValues = [8220, 34];\n  const lastDoubleQuote_CharValues = [8221, 34];\n\n  // Need Valid MLA inline-citation\n\n  // function stripParenthesis(citation) {\n  //   return citation.replace(/[{()}]/g, '');\n  // }\n\n  function stripQuotations(quote) {\n    // console.log(typeof editQuote);\n\n    if (firstDoubleQuote_CharValues.includes(quote.charCodeAt(0))) {\n      quote = quote.substring(1);\n    }\n    if (lastDoubleQuote_CharValues.includes(quote.charCodeAt(quote.length - 1))) {\n      quote = quote.substring(0, quote.length - 1);\n    }\n    quote.replace(\"\\\"\", \"\");\n    return quote;\n  }\n  function checkCitationInList(quote, citation) {\n    let citationObj = undefined;\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let key = Object.keys(dataEntriesList[i]).toString();\n      if (quote === key) {\n        console.log(\"QUOTE: \" + quote);\n        let values = dataEntriesList[quote];\n        console.log(values);\n        if (values === undefined) {\n          citationObj = {};\n          citationObj[citation] = [];\n          dataEntriesList[quote] = citationObj;\n        } else if (values.length === 2) {\n          citationObj = values[0];\n          let citeKey = Object.keys(citationObj).toString();\n          if (citeKey === citation) {\n            console.log(\"Citation exists in data!\");\n            return citationObj;\n          }\n        } else if (values.length === 1) {\n          console.log(\"How? Maybe citation obj wasn't created yet\");\n        } else {}\n      } else {\n        console.log(\"No quote for citation!\");\n      }\n    }\n\n    // After all keys have been checked, return an error (OR) add citation to citationErrors.\n    return citationObj;\n  }\n  function checkQuoteInList(quote) {\n    quote = stripQuotations(quote);\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      console.log(quoteToCheck);\n      if (quote === quoteToCheck) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /* For now, there should only be one quote per citation! This will flip some time soon*/\n  function addCitation(quote, citation) {\n    // console.log(\"Adding citation to array\");\n    quote = stripQuotations(quote);\n    let hasQuote = checkQuoteInList(quote);\n    let citationObj = checkCitationInList(quote, citation);\n    let quoteErrors = getQuoteErrors(quote);\n    console.log(\"PRINTING\");\n    console.log(quoteErrors);\n    let values = citationObj;\n    if (hasQuote) {\n      if (citationObj === undefined) {\n        console.log(\"HERE?\");\n        if (values === undefined) {\n          // Initialize the value for the citation\n          citationObj = {};\n          citationObj[citation] = [];\n          values = [];\n          values.unshift(citationObj);\n          // console.log(\"Checking: \" +citationObj[values][0])\n        } else {\n          citationObj = {};\n          citationObj[citation] = [];\n          values.unshift(citationObj);\n        }\n        dataEntriesList[quote] = values;\n        console.log(values);\n        // quotesList.quote = values;\n        for (let [key, value] of Object.entries(citationObj)) {\n          console.log(\"Key: \" + key + \" Value: \" + value);\n        }\n      } else {\n        console.log(\"There is no quote for this citation!\");\n        // Error\n      }\n    }\n\n    console.log(JSON.stringify(dataEntriesList));\n  }\n  function getQuoteErrors(quote) {\n    let quoteErrors;\n    quote = stripQuotations(quote);\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let [key, value] = Object.entries(dataEntriesList[i]).toString();\n      if (quote === key) {\n        quoteErrors = value;\n        return quoteErrors;\n      }\n    }\n    return quoteErrors;\n  }\n  function addQuote(quote, secIndex, index) {\n    console.log(\"Adding quote\");\n    quote = stripQuotations(quote);\n    const dataHasQuote = checkQuoteInList(quote);\n    if (dataHasQuote) {\n      console.log(\"Trying to add another of the same quote, ehh?\");\n    } else {\n      let newQuoteObj = new Quote(quote);\n      console.log(newQuoteObj);\n      dataEntriesList.push(newQuoteObj);\n    }\n  }\n  function addQuoteError(quote, errorMessage) {\n    console.log(\"Adding quote error!\");\n    quote = stripQuotations(quote);\n    const dataHasQuote = checkQuoteInList(quote);\n    if (dataHasQuote) {\n      let index = 0;\n      for (let i = 0; i < dataEntriesList.length; i++) {\n        let key = Object.keys(dataEntriesList[i]).toString();\n        if (quote === key) {\n          index = i;\n          break;\n        }\n      }\n      let value = Object.keys(dataEntriesList)[index];\n      value.push(errorMessage);\n      console.log(\"Error pushed into quote\");\n    } else {\n      console.log(\"SYSTEM ERROR: shouldn't add error before quote is made\");\n    }\n\n    // for (let [key, value] in Object.entries(quotesList)) {\n    //   console.log(\"Key: \" +key+ \" Value: \" +value);\n    // }\n  }\n\n  function addDocumentError(errorMessage) {\n    let citation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    if (citation !== undefined) {\n      let errors = citationsErrorList[citation];\n      if (errors === undefined) {\n        let newObj = {};\n        let errorArray = [];\n        errorArray.push(errorMessage);\n        newObj[citation] = errorArray;\n        citationsErrorList.push(newObj);\n      } else {\n        console.log(\"Adding additional error message to citation W/OUT quote!\");\n        errors.push(errorMessage);\n        citationsErrorList[citation] = errors; // I don't know if this adds a new array, if the array was already instantiated, or if this is completely uncessary :D\n      }\n    } else {\n      documentErrorList.push(errorMessage);\n    }\n  }\n\n  // function addCitationError(quote, citation, errorMessage) {\n  //   const dataHasQuote = checkQuoteInList(quote);\n\n  //     if (dataHasQuote) {\n  //       let index = 0;\n\n  //       for (let i = 0; i < dataEntriesList.length; i++) {\n  //         let [key, value] = Object.keys(dataEntriesList(i));\n  //         if (quote === key) {\n  //           index = i;\n  //           break;\n  //         }\n  //       }\n\n  //       // Do citation work\n  //     }\n\n  // }\n\n  function removeMlaDecimal(word) {\n    const chars = word.split('');\n    if (chars[word.length - 1] === '.') {\n      // If the last character is a decimal, remove it!\n      const result = word.slice(0, -1);\n      return result;\n    } else {\n      return word;\n    }\n  }\n  function findMlaBlockCitation(wordsInSection) {\n    if (wordsInSection[wordsInSection.length - 1].includes(\")\")) {\n      // Checks if last word contains ending parenthesis. Possible block citation!\n      let citation = [];\n      let quote = [];\n\n      /* Going backwards in this section! :) */\n      for (let i = 0; i < wordsInSection - 1; i++) {\n        let startedCitationIndex = i;\n        while (true) {\n          i++;\n          let word = wordsInSection[i];\n          citation = findMlaCitations(word, startedCitationIndex + 1, i, citation);\n          if (citation[0].includes(\")\") && citation[0].includes(\"(\")) {\n            // If citation was found\n            addQuote(quote.join(\" \"));\n            addCitation(quote.join(\" \"), citation.join(\" \"));\n            return true;\n          } else if (!citation[0].includes(\"(\")) {\n            quote.push(word);\n          } else if (citation[0].includes(\"(\")) {\n            citation.push(word);\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /* */\n  function findMlaCitations(word, startedCitationIndex, i, citation) {\n    if (!word.includes(\"(\") && startedCitationIndex === i) {\n      // If beginning of citation and doesn't include open parenthesis.\n      console.log(\"Citation does not come right after quote! WHOOPS\");\n      return [citation.join(\" \")];\n      // Do more...\n\n      // If citing doesn't come right after quote, check if it's later in the same section.\n      // while (true) {\n      //   i++;\n      //   word = inputWords[i];\n\n      //   // Check if the next word is the citing.\n      //   if (word.includes(\"(\")) {\n\n      //   } else { // If the word doesn't contain a parenthesis, find the next quote.\n\n      //   }\n\n      // }\n    } else if (word.includes(\"(\") && startedCitationIndex === i) {\n      // If citation is right after quote.\n      // word.replace(/[(]/g, '');\n\n      if (word.includes(\")\")) {\n        // If word is also end of citation too.\n        // word.replace(/[)]/g, '');\n        // console.log(word);\n        const finalWord = removeMlaDecimal(word);\n        citation.push(finalWord);\n        return [citation.join(\" \")];\n      }\n      // if (word.includes(\",\")) { // If the word has a comma, remove it\n      //   word.replace(/[,]/g, '');\n      // }\n      citation.push(word);\n    } else if (word.includes(\")\")) {\n      // If this is the end of the citation.\n      word.replace(/[)]/g, '');\n      // console.log(word);\n      const finalWord = removeMlaDecimal(word);\n      citation.push(finalWord);\n      return [citation.join(\" \")];\n    } else {\n      // console.log(word);\n      citation.push(word);\n    }\n    return [citation.join(\" \")];\n  }\n  function findMlaQuotes(startingIndex, inputSections, sectionWorksCited) {\n    // console.log(startingIndex+ \" \" +inputSections+ \" \" +sectionWorksCited);\n\n    for (let secIndex = startingIndex; secIndex < sectionWorksCited; secIndex++) {\n      // console.log(\"Section index: \" +secIndex);\n      let currentSection = inputSections[secIndex].replace('\\t', \"\");\n      const wordsInSection = currentSection.split(\" \");\n      // console.log(wordsInSection.length);\n      let containsQuoteInSection = false;\n\n      /* Time to find the quotes in a section*/\n      for (let i = 0; i < wordsInSection.length; i++) {\n        let word = wordsInSection[i];\n        // console.log(\"Char code? \" +word+ \" \" +word.charCodeAt((word.length -1)));\n        // console.log(word);\n        let containsQuote = false;\n        let quote;\n        let error;\n        if (firstDoubleQuote_CharValues.includes(word.charCodeAt(0))) {\n          // First quoted word found, now find the last.\n          // console.log(\"Checking: \" +word);\n          let wordsInQuote = [];\n          wordsInQuote.push(word);\n          let containsQuotationError = false;\n          while (true) {\n            // Checking word with ending quotation marks!\n            i++;\n            word = wordsInSection[i];\n            const containsFinalQuote = lastDoubleQuote_CharValues.includes(word.charCodeAt(word.length - 1));\n            wordsInQuote.push(word);\n            if (containsFinalQuote) {\n              containsQuoteInSection = true;\n              containsQuote = true;\n              break;\n            } else if (word.includes(\"(\")) {\n              // If a citation comes before an ending parenthesis, tell the user.\n              error = \"Missing ending parenthesis. Is it possible that a parenthesis was added inside of a quote?\";\n              containsQuotationError = true;\n              break;\n            } else if (i === wordsInSection.length - 1) {\n              // If this is the last word in the section and doesn't contain any quotes, tell the user.\n              error = \"Missing ending quotation marks!\";\n              containsQuotationError = true;\n              break;\n            }\n          }\n          if (!containsQuote) {\n            break;\n          }\n          quote = wordsInQuote.join(\" \");\n          addQuote(quote, secIndex, i);\n          if (containsQuotationError) {\n            // If there is a quotation error, go back 1 word and give error to almost made quotation!\n            i--;\n            addQuoteError(quote, error);\n          }\n          let startedCitationIndex = i;\n          let containsCitation = false;\n          let citation = [];\n\n          // Get the citing of the quote after the quotation marks.\n          while (true) {\n            i++;\n            word = wordsInSection[i];\n            // console.log(word);\n\n            citation = findMlaCitations(word, startedCitationIndex + 1, i, citation);\n            if (citation[0].includes(\")\") && citation[0].includes(\"(\")) {\n              // If citation was found\n              containsCitation = true;\n              break;\n            } else if (i === wordsInSection.length - 1) {\n              // If last word in section and no citation found, break...\n              addQuoteError(quote, \"No citation found for quote\");\n              break;\n            }\n          }\n          if (citation !== undefined) {\n            citation = citation[0];\n          }\n          if (containsCitation && containsQuote) {\n            addCitation(quote, citation);\n            // console.log(\"Citations: \" +citations);\n          } else if (containsCitation) {\n            addDocumentError(\"No quote exists for the given citation\", citation);\n            console.log(\"Citation errors\");\n            console.log(documentErrorList);\n          } else {\n            let quoteKey = Object.keys(dataEntriesList.length - 1);\n            console.log(\"Quote: \" + quoteKey + \" does not have a citation\");\n          }\n\n          /* Add Citation error if there is one!*/\n        }\n\n        if (!containsQuote) {\n          break; // Move to next section.\n        }\n      }\n\n      if (!containsQuoteInSection) {\n        // If the section does not contain a quote. Could it be a block citation?\n        console.log(\"Trying block quote\");\n        let isBlockCitation = findMlaBlockCitation(wordsInSection);\n        if (isBlockCitation) {\n          console.log(\"It is a Block Citation\");\n        } else {\n          console.log(\"No citations in this paragraph! :)\");\n        }\n      }\n    }\n  }\n  function checkMlaHandler(e) {\n    e.preventDefault();\n    documentErrorList = [];\n    citationsErrorList = [];\n    dataEntriesList = [];\n    const inputText = document.getElementById(\"inputText\").value;\n    if (inputText === undefined) {\n      return;\n    }\n    const inputSections = inputText.split(\"\\n\");\n    console.log(\"Number of sections: \" + inputSections.length);\n\n    /* Find the starting paragraph to parse! */\n    let startParsingIndex = 0;\n    for (let i = 0; i < inputSections.length; i++) {\n      if (inputSections[i].length > 50) {\n        startParsingIndex = i;\n        break;\n      }\n    }\n\n    /* If the starting section isn't 5, you are missing headers or added too many header/title lines */\n    if (startParsingIndex < 5) {\n      console.log(\"User is missing header information\");\n      return;\n    } else if (startParsingIndex > 6) {\n      // errors.push(\"User added too many header/title lines before introduction of paper\");\n      return;\n    }\n    let sectionWorksCited = inputSections.length - 1; // Give the section works cited the last section so the loop can work.\n    /* Check where the Works Cited page might exist! */\n    for (let sectionNum = startParsingIndex; sectionNum < inputSections.length; sectionNum++) {\n      if (inputSections[sectionNum].split(\" \").length === 2) {\n        sectionWorksCited = sectionNum;\n        // console.log(\"Possible Works Cited page on section \" +(sectionNum+1)+ \"?\");\n      }\n    }\n\n    findMlaQuotes(startParsingIndex, inputSections, sectionWorksCited);\n    const root = document.getElementById(\"result\");\n\n    /* This removes the nodes from the previous submitted text. */\n    root.innerHTML = '';\n\n    // const errorsRoot = document.getElementById(\"main-errors\");\n    // for (let i = 0; i < errors.length; i++) {\n    //   let errorText = document.createTextNode(errors[i]);\n    //   let error = document.createElement(\"th\");\n\n    //   error.appendChild(errorText);\n\n    //   let row = document.createElement(\"tr\");\n    //   row.appendChild(error);\n    //   errorsRoot.appendChild(row);\n    // }\n\n    // for (let i = 0; i < citations.length; i++) {\n    //   let citationText = document.createTextNode(citations[i]);\n    //   let quoteText = document.createTextNode(quotes[i]);\n\n    //   let quote = document.createElement(\"th\");\n    //   let citation = document.createElement(\"th\");\n    //   quote.appendChild(quoteText);\n    //   citation.appendChild(citationText);\n\n    //   let row = document.createElement(\"tr\");\n    //   row.appendChild(quote);\n    //   row.appendChild(citation);\n\n    //   root.appendChild(row);\n    // }\n\n    console.log(\"\\nEND\\n\\n\");\n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteKey = dataEntriesList[i].getKey();\n      console.log(\"Key: \" + quoteKey);\n    }\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"document\",\n      children: [/*#__PURE__*/_jsxDEV(\"textarea\", {\n        id: \"inputText\",\n        className: \"inputText\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 540,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: checkMlaHandler,\n        children: \"Check Text\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 541,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 539,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"result-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        id: \"title\",\n        className: \"title\",\n        children: \"Title\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 544,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        id: \"main-errors\",\n        className: \"main-errors\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 545,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        id: \"result\",\n        className: \"result\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 547,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 543,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 538,\n    columnNumber: 5\n  }, this);\n}\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["Quote","App","documentErrorList","dataEntriesList","citationsErrorList","firstDoubleQuote_CharValues","lastDoubleQuote_CharValues","stripQuotations","quote","includes","charCodeAt","substring","length","replace","checkCitationInList","citation","citationObj","undefined","i","key","Object","keys","toString","console","log","values","citeKey","checkQuoteInList","quoteToCheck","getQuote","addCitation","hasQuote","quoteErrors","getQuoteErrors","unshift","value","entries","JSON","stringify","addQuote","secIndex","index","dataHasQuote","newQuoteObj","push","addQuoteError","errorMessage","addDocumentError","errors","newObj","errorArray","removeMlaDecimal","word","chars","split","result","slice","findMlaBlockCitation","wordsInSection","startedCitationIndex","findMlaCitations","join","finalWord","findMlaQuotes","startingIndex","inputSections","sectionWorksCited","currentSection","containsQuoteInSection","containsQuote","error","wordsInQuote","containsQuotationError","containsFinalQuote","containsCitation","quoteKey","isBlockCitation","checkMlaHandler","e","preventDefault","inputText","document","getElementById","startParsingIndex","sectionNum","root","innerHTML","getKey"],"sources":["/usr/share/caddy/personal/formatter/src/App.js"],"sourcesContent":["import './App.css';\nimport {Quote} from './models/Quote.js';\n\nfunction App() {\n  \n  /* [{Quote: [[{Citation: [Citation Errors]}], [Quote Errors]]}, {...}, ...]*/\n  /**\n  Errors: documentErrors, intextErrors, worksCitedErrors.\n  \n  */\n  let documentErrorList;\n  let dataEntriesList;\n  let citationsErrorList;\n  const firstDoubleQuote_CharValues = [8220, 34];\n  const lastDoubleQuote_CharValues = [8221, 34];\n  \n  // Need Valid MLA inline-citation\n  \n  // function stripParenthesis(citation) {\n  //   return citation.replace(/[{()}]/g, '');\n  // }\n  \n  function stripQuotations(quote) {\n    // console.log(typeof editQuote);\n    \n    if (firstDoubleQuote_CharValues.includes(quote.charCodeAt(0))) {\n      quote = quote.substring(1);\n    }\n    if (lastDoubleQuote_CharValues.includes(quote.charCodeAt(quote.length -1))) {\n      quote = quote.substring(0, (quote.length -1));\n    }\n    quote.replace(\"\\\"\", \"\");\n    \n    return quote;\n  }\n  \n  function checkCitationInList(quote, citation) {\n    let citationObj = undefined;\n    \n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let key = Object.keys(dataEntriesList[i]).toString();\n      \n      if (quote === key) {\n        console.log(\"QUOTE: \"+quote);\n        let values = dataEntriesList[quote];\n        console.log(values);\n        \n        if (values === undefined) {\n          citationObj = {};\n          citationObj[citation] = [];\n          dataEntriesList[quote] = citationObj;\n          \n        } else if (values.length === 2) {\n          citationObj = values[0];\n          let citeKey = Object.keys(citationObj).toString();\n          \n          if (citeKey === citation) {\n            console.log(\"Citation exists in data!\");\n            return citationObj;\n          }\n          \n        } else if (values.length === 1) {\n          console.log(\"How? Maybe citation obj wasn't created yet\");\n          \n        } else {\n          \n        }\n        \n      } else {\n        console.log(\"No quote for citation!\");\n      }\n    }\n    \n    // After all keys have been checked, return an error (OR) add citation to citationErrors.\n    return citationObj;\n  }\n  \n  function checkQuoteInList(quote) {\n    quote = stripQuotations(quote);\n    \n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let quoteToCheck = dataEntriesList[i].getQuote();\n      console.log(quoteToCheck);\n      \n      if (quote === quoteToCheck) {\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  /* For now, there should only be one quote per citation! This will flip some time soon*/\n  function addCitation(quote, citation) {\n    // console.log(\"Adding citation to array\");\n    quote = stripQuotations(quote);\n    let hasQuote = checkQuoteInList(quote);\n    let citationObj = checkCitationInList(quote, citation);\n    let quoteErrors = getQuoteErrors(quote);\n    console.log(\"PRINTING\");\n    console.log(quoteErrors);\n    let values = citationObj;\n    \n    if (hasQuote) {\n      if (citationObj === undefined) {\n        console.log(\"HERE?\");\n        \n        if (values === undefined) { // Initialize the value for the citation\n          citationObj = {};\n          citationObj[citation] = [];\n          values = [];\n          values.unshift(citationObj);\n          // console.log(\"Checking: \" +citationObj[values][0])\n        } else {\n          citationObj = {};\n          citationObj[citation] = [];\n          values.unshift(citationObj);\n        }\n        \n        dataEntriesList[quote] = values;\n        \n        console.log(values);\n        // quotesList.quote = values;\n        for (let [key, value] of Object.entries(citationObj)) {\n          console.log(\"Key: \" +key+ \" Value: \" +value);\n        }\n        \n      } else {\n        console.log(\"There is no quote for this citation!\");\n        // Error\n      }\n    }\n    \n    console.log(JSON.stringify(dataEntriesList));\n    \n  }\n  \n  function getQuoteErrors(quote) {\n    let quoteErrors;\n    quote = stripQuotations(quote);\n    \n    for (let i = 0; i < dataEntriesList.length; i++) {\n      let [key, value] = Object.entries(dataEntriesList[i]).toString();\n      \n      if (quote === key) {\n        quoteErrors = value;\n        return quoteErrors;\n      }\n    }\n    return quoteErrors;\n  }\n  \n  function addQuote(quote, secIndex, index) {\n    console.log(\"Adding quote\");\n    quote = stripQuotations(quote);\n    const dataHasQuote = checkQuoteInList(quote);\n    \n    if (dataHasQuote) {\n      console.log(\"Trying to add another of the same quote, ehh?\");\n    } else {\n      let newQuoteObj = new Quote(quote);\n      console.log(newQuoteObj);\n      dataEntriesList.push(newQuoteObj);\n    }\n    \n  }\n  \n  function addQuoteError(quote, errorMessage) {\n    console.log(\"Adding quote error!\");\n    \n    quote = stripQuotations(quote);\n    const dataHasQuote = checkQuoteInList(quote);\n    \n    if (dataHasQuote) {\n      let index = 0;\n      \n      for (let i = 0; i < dataEntriesList.length; i++) {\n        let key = Object.keys(dataEntriesList[i]).toString();\n        \n        if (quote === key) {\n          index = i;\n          break;\n        }\n      }\n      \n      let value = Object.keys(dataEntriesList)[index];\n      value.push(errorMessage);\n      console.log(\"Error pushed into quote\");\n      \n    } else {\n      console.log(\"SYSTEM ERROR: shouldn't add error before quote is made\");\n    }\n    \n    // for (let [key, value] in Object.entries(quotesList)) {\n    //   console.log(\"Key: \" +key+ \" Value: \" +value);\n    // }\n  }\n  \n  function addDocumentError(errorMessage, citation = undefined) {\n    if (citation !== undefined) {\n      let errors = citationsErrorList[citation];\n      \n      if (errors === undefined) {\n        let newObj = {};\n        let errorArray = [];\n        errorArray.push(errorMessage);\n        newObj[citation] = errorArray;\n        citationsErrorList.push(newObj);\n      } else {\n        console.log(\"Adding additional error message to citation W/OUT quote!\");\n        errors.push(errorMessage);\n        citationsErrorList[citation] = errors; // I don't know if this adds a new array, if the array was already instantiated, or if this is completely uncessary :D\n      }\n      \n    } else {\n      documentErrorList.push(errorMessage);\n    }\n    \n  }\n  \n  // function addCitationError(quote, citation, errorMessage) {\n  //   const dataHasQuote = checkQuoteInList(quote);\n      \n  //     if (dataHasQuote) {\n  //       let index = 0;\n        \n  //       for (let i = 0; i < dataEntriesList.length; i++) {\n  //         let [key, value] = Object.keys(dataEntriesList(i));\n  //         if (quote === key) {\n  //           index = i;\n  //           break;\n  //         }\n  //       }\n        \n  //       // Do citation work\n  //     }\n    \n  // }\n  \n  function removeMlaDecimal(word) {\n    const chars = word.split('');\n    if (chars[(word.length-1)] === '.') { // If the last character is a decimal, remove it!\n      const result = word.slice(0, -1);\n      return result;\n    } else {\n      return word;\n    }\n  }\n  \n  function findMlaBlockCitation(wordsInSection) {\n    \n    if (wordsInSection[wordsInSection.length -1].includes(\")\")) { // Checks if last word contains ending parenthesis. Possible block citation!\n      let citation = [];\n      let quote = [];\n    \n      /* Going backwards in this section! :) */\n      for (let i = 0; i < (wordsInSection -1); i++) {\n        let startedCitationIndex = i;\n        \n        while (true) {\n          i++;\n          let word = wordsInSection[i];\n          \n          citation = findMlaCitations(word, startedCitationIndex+1, i, citation);\n          \n          if (citation[0].includes(\")\") && citation[0].includes(\"(\")) { // If citation was found\n            addQuote(quote.join(\" \"));\n            addCitation(quote.join(\" \"), citation.join(\" \"));\n            return true;\n          } else if (!citation[0].includes(\"(\")) {\n            quote.push(word);\n          } else if (citation[0].includes(\"(\")) {\n            citation.push(word);\n          }\n        }\n      }\n    }\n    \n    return false;\n  }\n  \n  /* */\n  function findMlaCitations(word, startedCitationIndex, i, citation) {\n    \n    if (!word.includes(\"(\") && (startedCitationIndex === i)) { // If beginning of citation and doesn't include open parenthesis.\n      console.log(\"Citation does not come right after quote! WHOOPS\");\n      return [citation.join(\" \")];\n      // Do more...\n      \n      // If citing doesn't come right after quote, check if it's later in the same section.\n      // while (true) {\n      //   i++;\n      //   word = inputWords[i];\n        \n      //   // Check if the next word is the citing.\n      //   if (word.includes(\"(\")) {\n          \n          \n      //   } else { // If the word doesn't contain a parenthesis, find the next quote.\n          \n      //   }\n        \n      // }\n      \n    } else if (word.includes(\"(\") && (startedCitationIndex === i)) { // If citation is right after quote.\n      // word.replace(/[(]/g, '');\n      \n      if (word.includes(\")\")) { // If word is also end of citation too.\n        // word.replace(/[)]/g, '');\n        // console.log(word);\n        const finalWord = removeMlaDecimal(word);\n        citation.push(finalWord);\n        return [citation.join(\" \")];\n      }\n      // if (word.includes(\",\")) { // If the word has a comma, remove it\n      //   word.replace(/[,]/g, '');\n      // }\n      citation.push(word);\n      \n    } else if (word.includes(\")\")) { // If this is the end of the citation.\n      word.replace(/[)]/g, '');\n      // console.log(word);\n      const finalWord = removeMlaDecimal(word);\n      citation.push(finalWord);\n      return [citation.join(\" \")];\n      \n    } else {\n      // console.log(word);\n      citation.push(word);\n    }\n    \n    return [citation.join(\" \")];\n  }\n  \n  function findMlaQuotes(startingIndex, inputSections, sectionWorksCited) {\n    // console.log(startingIndex+ \" \" +inputSections+ \" \" +sectionWorksCited);\n    \n    for (let secIndex = startingIndex; secIndex < sectionWorksCited; secIndex++) {\n      // console.log(\"Section index: \" +secIndex);\n      let currentSection = inputSections[secIndex].replace('\\t', \"\");\n      const wordsInSection = currentSection.split(\" \");\n      // console.log(wordsInSection.length);\n      let containsQuoteInSection = false;\n      \n      /* Time to find the quotes in a section*/\n      for (let i = 0; i < wordsInSection.length; i++) {\n        let word = wordsInSection[i];\n        // console.log(\"Char code? \" +word+ \" \" +word.charCodeAt((word.length -1)));\n        // console.log(word);\n        let containsQuote = false;\n        let quote;\n        let error;\n        \n        if (firstDoubleQuote_CharValues.includes(word.charCodeAt(0))) { // First quoted word found, now find the last.\n          // console.log(\"Checking: \" +word);\n          let wordsInQuote = [];\n          wordsInQuote.push(word);\n          let containsQuotationError = false;\n          \n          while (true) { // Checking word with ending quotation marks!\n            i++;\n            word = wordsInSection[i];\n            \n            const containsFinalQuote = (lastDoubleQuote_CharValues.includes(word.charCodeAt(word.length -1)));\n            wordsInQuote.push(word);\n            \n            if (containsFinalQuote) {\n              containsQuoteInSection = true;\n              containsQuote = true;\n              break;\n            } else if (word.includes(\"(\")) { // If a citation comes before an ending parenthesis, tell the user.\n              error = \"Missing ending parenthesis. Is it possible that a parenthesis was added inside of a quote?\";\n              containsQuotationError = true;\n              break;\n            } else if (i === (wordsInSection.length -1)) { // If this is the last word in the section and doesn't contain any quotes, tell the user.\n              error = \"Missing ending quotation marks!\";\n              containsQuotationError = true;\n              break;\n            }\n          }\n          \n          if (!containsQuote) {\n            break;\n          }\n          \n          quote = wordsInQuote.join(\" \");\n          addQuote(quote, secIndex, i);\n          \n          if (containsQuotationError) { // If there is a quotation error, go back 1 word and give error to almost made quotation!\n            i--;\n            addQuoteError(quote, error);\n          }\n          \n          let startedCitationIndex = i;\n          let containsCitation = false;\n          let citation = [];\n          \n          // Get the citing of the quote after the quotation marks.\n          while (true) {\n            i++;\n            word = wordsInSection[i];\n            // console.log(word);\n            \n            citation = findMlaCitations(word, startedCitationIndex+1, i, citation);\n            \n            if (citation[0].includes(\")\") && citation[0].includes(\"(\")) { // If citation was found\n              containsCitation = true;\n              break;\n            } else if (i === (wordsInSection.length -1)) { // If last word in section and no citation found, break...\n              addQuoteError(quote, \"No citation found for quote\");\n              break;\n            }\n          }\n          \n          if (citation !== undefined) {\n            citation = citation[0];\n          }\n          \n          if (containsCitation && containsQuote) {\n            addCitation(quote, citation);\n            // console.log(\"Citations: \" +citations);\n          } else if (containsCitation) {\n            addDocumentError(\"No quote exists for the given citation\", citation);\n            console.log(\"Citation errors\");\n            console.log(documentErrorList);\n          } else {\n            let quoteKey = (Object.keys(dataEntriesList.length -1));\n            console.log(\"Quote: \" +quoteKey+ \" does not have a citation\");\n          }\n          \n          /* Add Citation error if there is one!*/\n          \n        }\n        \n        if (!containsQuote) {\n          break; // Move to next section.\n        }\n      }\n      \n      if (!containsQuoteInSection) { // If the section does not contain a quote. Could it be a block citation?\n        console.log(\"Trying block quote\");\n        let isBlockCitation = findMlaBlockCitation(wordsInSection);\n        \n        if (isBlockCitation) {\n          console.log(\"It is a Block Citation\");\n        } else {\n          console.log(\"No citations in this paragraph! :)\");\n        }\n      }\n    }\n  }\n  \n  function checkMlaHandler(e) {\n    e.preventDefault();\n    documentErrorList = [];\n    citationsErrorList = [];\n    dataEntriesList = [];\n    \n    const inputText = document.getElementById(\"inputText\").value;\n    \n    if (inputText === undefined) {\n      return;\n    }\n    \n    const inputSections = inputText.split(\"\\n\");\n    console.log(\"Number of sections: \" +inputSections.length);\n    \n    /* Find the starting paragraph to parse! */\n    let startParsingIndex = 0;\n    for (let i = 0; i < inputSections.length; i++) {\n      if (inputSections[i].length > 50) {\n        startParsingIndex = i;\n        break;\n      }\n    }\n    \n    /* If the starting section isn't 5, you are missing headers or added too many header/title lines */\n    if (startParsingIndex < 5) {\n      console.log(\"User is missing header information\");\n      return;\n    } else if (startParsingIndex > 6) {\n      // errors.push(\"User added too many header/title lines before introduction of paper\");\n      return;\n    }\n    \n    let sectionWorksCited = (inputSections.length -1); // Give the section works cited the last section so the loop can work.\n    /* Check where the Works Cited page might exist! */\n    for (let sectionNum = startParsingIndex; sectionNum < inputSections.length; sectionNum++) {\n      if (inputSections[sectionNum].split(\" \").length === 2) {\n        sectionWorksCited = sectionNum;\n        // console.log(\"Possible Works Cited page on section \" +(sectionNum+1)+ \"?\");\n      }\n    }\n    \n    findMlaQuotes(startParsingIndex, inputSections, sectionWorksCited);\n    \n    const root = document.getElementById(\"result\");\n    \n    /* This removes the nodes from the previous submitted text. */\n    root.innerHTML = '';\n    \n    // const errorsRoot = document.getElementById(\"main-errors\");\n    // for (let i = 0; i < errors.length; i++) {\n    //   let errorText = document.createTextNode(errors[i]);\n    //   let error = document.createElement(\"th\");\n      \n    //   error.appendChild(errorText);\n      \n    //   let row = document.createElement(\"tr\");\n    //   row.appendChild(error);\n    //   errorsRoot.appendChild(row);\n    // }\n    \n    // for (let i = 0; i < citations.length; i++) {\n    //   let citationText = document.createTextNode(citations[i]);\n    //   let quoteText = document.createTextNode(quotes[i]);\n      \n    //   let quote = document.createElement(\"th\");\n    //   let citation = document.createElement(\"th\");\n    //   quote.appendChild(quoteText);\n    //   citation.appendChild(citationText);\n      \n    //   let row = document.createElement(\"tr\");\n    //   row.appendChild(quote);\n    //   row.appendChild(citation);\n      \n    //   root.appendChild(row);\n    // }\n    \n    \n    console.log(\"\\nEND\\n\\n\");\n    for (let i = 0; i < dataEntriesList.length; i ++) {\n      let quoteKey = dataEntriesList[i].getKey();\n      console.log(\"Key: \" +quoteKey);\n    }\n  }\n  \n  return (\n    <div className=\"App\">\n      <div className=\"document\">\n        <textarea id=\"inputText\" className=\"inputText\"/>\n        <button onClick={checkMlaHandler}>Check Text</button>\n      </div>\n      <div className=\"result-container\">\n        <div id=\"title\" className=\"title\">Title</div>\n        <div id=\"main-errors\" className=\"main-errors\">\n        </div>\n        <div id=\"result\" className=\"result\">\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}